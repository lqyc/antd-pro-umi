{"version":3,"sources":["../../src/geo/lng_lat.ts"],"names":["earthRadius","LngLat","lng","lat","isNaN","Error","radius","earthCircumferenceInMetersAtEquator","latAccuracy","lngAccuracy","Math","cos","PI","LngLatBounds","lngLat","rad","lat1","lat2","a","sin","maxMeters","acos","min","input","Array","isArray","length","Number","lon"],"mappings":"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","sourcesContent":["import { wrap } from '../util';\nimport LngLatBounds from './lng_lat_bounds';\nexport const earthRadius = 6371008.8;\nexport type LngLatLike =\n  | LngLat\n  | { lng: number; lat: number }\n  | { lon: number; lat: number }\n  | [number, number];\n\nexport default class LngLat {\n  public static convert(input: LngLatLike): LngLat {\n    if (input instanceof LngLat) {\n      return input;\n    }\n    if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n    if (!Array.isArray(input) && typeof input === 'object' && input !== null) {\n      const lng = 'lng' in input ? input.lng : input.lon;\n      return new LngLat(\n        // flow can't refine this to have one of lng or lat, so we have to cast to any\n        Number(lng),\n        Number(input.lat),\n      );\n    }\n    throw new Error(\n      '`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]',\n    );\n  }\n  public lng: number;\n  public lat: number;\n  constructor(lng: number, lat: number) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\n        'Invalid LngLat latitude value: must be between -90 and 90',\n      );\n    }\n  }\n\n  public wrap() {\n    return new LngLat(wrap(this.lng, -180, 180), this.lat);\n  }\n  public toArray(): [number, number] {\n    return [this.lng, this.lat];\n  }\n  public toBounds(radius: number = 0) {\n    const earthCircumferenceInMetersAtEquator = 40075017;\n    const latAccuracy = (360 * radius) / earthCircumferenceInMetersAtEquator;\n    const lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\n\n    return new LngLatBounds(\n      new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),\n      new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy),\n    );\n  }\n  public toString() {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n  public distanceTo(lngLat: LngLat) {\n    const rad = Math.PI / 180;\n    const lat1 = this.lat * rad;\n    const lat2 = lngLat.lat * rad;\n    const a =\n      Math.sin(lat1) * Math.sin(lat2) +\n      Math.cos(lat1) * Math.cos(lat2) * Math.cos((lngLat.lng - this.lng) * rad);\n\n    const maxMeters = earthRadius * Math.acos(Math.min(a, 1));\n    return maxMeters;\n  }\n}\n"],"file":"lng_lat.js"}