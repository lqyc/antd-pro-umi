{"version":3,"sources":["../../src/utils/task_queue.ts"],"names":["TaskQueue","queue","id","cleared","currentlyRunning","callback","push","cancelled","running","concat","task","timeStamp"],"mappings":";;;;;;;;;;;;;;;;;;;IAOMA,S;AAMJ,uBAAc;AAAA;AAAA,SALNC,KAKM;AAAA,SAJNC,EAIM;AAAA,SAHNC,OAGM;AAAA,SAFNC,gBAEM;AACZ,SAAKH,KAAL,GAAa,EAAb;AACA,SAAKC,EAAL,GAAU,CAAV;AACA,SAAKC,OAAL,GAAe,KAAf;AACA,SAAKC,gBAAL,GAAwB,KAAxB;AACD;;;;WAED,aAAWC,QAAX,EAA0D;AACxD,UAAMH,EAAE,GAAG,EAAE,KAAKA,EAAlB;AACA,UAAMD,KAAK,GAAG,KAAKA,KAAnB;AACAA,MAAAA,KAAK,CAACK,IAAN,CAAW;AAAED,QAAAA,QAAQ,EAARA,QAAF;AAAYH,QAAAA,EAAE,EAAFA,EAAZ;AAAgBK,QAAAA,SAAS,EAAE;AAA3B,OAAX;AACA,aAAOL,EAAP;AACD;;;WAED,gBAAcA,EAAd,EAA0B;AACxB,UAAMM,OAAO,GAAG,KAAKJ,gBAArB;AACA,UAAMH,KAAK,GAAGO,OAAO,GAAG,KAAKP,KAAL,CAAWQ,MAAX,CAAkBD,OAAlB,CAAH,GAAgC,KAAKP,KAA1D;;AAFwB,iDAGLA,KAHK;AAAA;;AAAA;AAGxB,4DAA0B;AAAA,cAAfS,IAAe;;AACxB,cAAIA,IAAI,CAACR,EAAL,KAAYA,EAAhB,EAAoB;AAClBQ,YAAAA,IAAI,CAACH,SAAL,GAAiB,IAAjB;AACA;AACD;AACF;AARuB;AAAA;AAAA;AAAA;AAAA;AASzB;;;WAED,eAAkC;AAAA,UAAvBI,SAAuB,uEAAH,CAAG;AAChC,UAAMV,KAAK,GAAI,KAAKG,gBAAL,GAAwB,KAAKH,KAA5C;AAIA,WAAKA,KAAL,GAAa,EAAb;;AALgC,kDAObA,KAPa;AAAA;;AAAA;AAOhC,+DAA0B;AAAA,cAAfS,IAAe;;AACxB,cAAIA,IAAI,CAACH,SAAT,EAAoB;AAClB;AACD;;AACDG,UAAAA,IAAI,CAACL,QAAL,CAAcM,SAAd;;AACA,cAAI,KAAKR,OAAT,EAAkB;AAChB;AACD;AACF;AAf+B;AAAA;AAAA;AAAA;AAAA;;AAiBhC,WAAKA,OAAL,GAAe,KAAf;AACA,WAAKC,gBAAL,GAAwB,KAAxB;AACD;;;WAED,iBAAe;AACb,UAAI,KAAKA,gBAAT,EAA2B;AACzB,aAAKD,OAAL,GAAe,IAAf;AACD;;AACD,WAAKF,KAAL,GAAa,EAAb;AACD;;;;;eAGYD,S","sourcesContent":["export type TaskID = number; // can't mark opaque due to https://github.com/flowtype/flow-remove-types/pull/61\ninterface ITask {\n  callback: (timeStamp: number) => void;\n  id: TaskID;\n  cancelled: boolean;\n}\n\nclass TaskQueue {\n  private queue: ITask[];\n  private id: TaskID;\n  private cleared: boolean;\n  private currentlyRunning: ITask[] | false;\n\n  constructor() {\n    this.queue = [];\n    this.id = 0;\n    this.cleared = false;\n    this.currentlyRunning = false;\n  }\n\n  public add(callback: (timeStamp: number) => void): TaskID {\n    const id = ++this.id;\n    const queue = this.queue;\n    queue.push({ callback, id, cancelled: false });\n    return id;\n  }\n\n  public remove(id: TaskID) {\n    const running = this.currentlyRunning;\n    const queue = running ? this.queue.concat(running) : this.queue;\n    for (const task of queue) {\n      if (task.id === id) {\n        task.cancelled = true;\n        return;\n      }\n    }\n  }\n\n  public run(timeStamp: number = 0) {\n    const queue = (this.currentlyRunning = this.queue);\n\n    // Tasks queued by callbacks in the current queue should be executed\n    // on the next run, not the current run.\n    this.queue = [];\n\n    for (const task of queue) {\n      if (task.cancelled) {\n        continue;\n      }\n      task.callback(timeStamp);\n      if (this.cleared) {\n        break;\n      }\n    }\n\n    this.cleared = false;\n    this.currentlyRunning = false;\n  }\n\n  public clear() {\n    if (this.currentlyRunning) {\n      this.cleared = true;\n    }\n    this.queue = [];\n  }\n}\n\nexport default TaskQueue;\n"],"file":"task_queue.js"}