{"version":3,"sources":["../../src/utils/Aabb.ts"],"names":["Aabb","min","max","center","vec3","scale","Float32Array","add","index","split","qMin","clone","qMax","axis","length","point","pointOnAabb","Math","frustum","aabbPoints","fullyInside","planes","plane","pointsInside","i","vec4","dot","projMin","Number","MAX_VALUE","projMax","points","p","projectedPoint"],"mappings":"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","sourcesContent":["import { vec3, vec4 } from 'gl-matrix';\nimport Frustum from './primitives';\nexport default class Aabb {\n  public min: vec3;\n  public max: vec3;\n  public center: vec3;\n\n  constructor(min: vec3, max: vec3) {\n    this.min = min;\n    this.max = max;\n    this.center = vec3.scale(\n      new Float32Array(3),\n      vec3.add(new Float32Array(3), this.min, this.max),\n      0.5,\n    );\n  }\n\n  public quadrant(index: number): Aabb {\n    const split = [index % 2 === 0, index < 2];\n    const qMin = vec3.clone(this.min);\n    const qMax = vec3.clone(this.max);\n    for (let axis = 0; axis < split.length; axis++) {\n      qMin[axis] = split[axis] ? this.min[axis] : this.center[axis];\n      qMax[axis] = split[axis] ? this.center[axis] : this.max[axis];\n    }\n    // Elevation is always constant, hence quadrant.max.z = this.max.z\n    qMax[2] = this.max[2];\n    return new Aabb(qMin, qMax);\n  }\n\n  public distanceX(point: number[]): number {\n    const pointOnAabb = Math.max(Math.min(this.max[0], point[0]), this.min[0]);\n    return pointOnAabb - point[0];\n  }\n\n  public distanceY(point: number[]): number {\n    const pointOnAabb = Math.max(Math.min(this.max[1], point[1]), this.min[1]);\n    return pointOnAabb - point[1];\n  }\n\n  // Performs a frustum-aabb intersection test. Returns 0 if there's no intersection,\n  // 1 if shapes are intersecting and 2 if the aabb if fully inside the frustum.\n  public intersects(frustum: Frustum): number {\n    // Execute separating axis test between two convex objects to find intersections\n    // Each frustum plane together with 3 major axes define the separating axes\n    // Note: test only 4 points as both min and max points have equal elevation\n\n    const aabbPoints = [\n      [this.min[0], this.min[1], 0.0, 1],\n      [this.max[0], this.min[1], 0.0, 1],\n      [this.max[0], this.max[1], 0.0, 1],\n      [this.min[0], this.max[1], 0.0, 1],\n    ];\n\n    let fullyInside = true;\n\n    for (const plane of frustum.planes) {\n      let pointsInside = 0;\n\n      for (const i of aabbPoints) {\n        // @ts-ignore\n        pointsInside += vec4.dot(plane, i) >= 0;\n      }\n\n      if (pointsInside === 0) {\n        return 0;\n      }\n\n      if (pointsInside !== aabbPoints.length) {\n        fullyInside = false;\n      }\n    }\n\n    if (fullyInside) {\n      return 2;\n    }\n\n    for (let axis = 0; axis < 3; axis++) {\n      let projMin = Number.MAX_VALUE;\n      let projMax = -Number.MAX_VALUE;\n\n      for (const p of frustum.points) {\n        const projectedPoint = p[axis] - this.min[axis];\n\n        projMin = Math.min(projMin, projectedPoint);\n        projMax = Math.max(projMax, projectedPoint);\n      }\n\n      if (projMax < 0 || projMin > this.max[axis] - this.min[axis]) {\n        return 0;\n      }\n    }\n\n    return 1;\n  }\n}\n"],"file":"Aabb.js"}