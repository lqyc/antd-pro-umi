import { EventEmitter } from 'eventemitter3';
import { IPaddingOptions } from './geo/edge_insets';
import LngLat, { LngLatLike } from './geo/lng_lat';
import { LngLatBoundsLike } from './geo/lng_lat_bounds';
import { PointLike } from './geo/point';
import Transform from './geo/transform';
import { IMapOptions } from './interface';
declare type CallBack = (_: number) => void;
export interface ICameraOptions {
    center?: LngLatLike;
    zoom?: number;
    bearing?: number;
    pitch?: number;
    around?: LngLatLike;
    padding?: IPaddingOptions;
}
export interface IAnimationOptions {
    duration?: number;
    easing?: (_: number) => number;
    offset?: PointLike;
    animate?: boolean;
    essential?: boolean;
    linear?: boolean;
}
export default class Camera extends EventEmitter {
    transform: Transform;
    protected options: IMapOptions;
    protected moving: boolean;
    protected zooming: boolean;
    protected rotating: boolean;
    protected pitching: boolean;
    protected padding: boolean;
    private bearingSnap;
    private easeEndTimeoutID;
    private easeStart;
    private easeOptions;
    private easeId;
    private onEaseFrame;
    private onEaseEnd;
    private easeFrameId;
    constructor(options: IMapOptions);
    requestRenderFrame(cb: CallBack): number;
    cancelRenderFrame(_: number): void;
    getCenter(): LngLat;
    getZoom(): number;
    getPitch(): number;
    setCenter(center: LngLatLike, eventData?: any): boolean;
    setPitch(pitch: number, eventData?: any): this;
    getBearing(): number;
    panTo(lnglat: LngLatLike, options?: IAnimationOptions, eventData?: any): this;
    zoomOut(options?: IAnimationOptions, eventData?: any): this;
    setBearing(bearing: number, eventData?: any): this;
    setZoom(zoom: number, eventData?: any): this;
    zoomIn(options?: IAnimationOptions, eventData?: any): this;
    zoomTo(zoom: number, options?: IAnimationOptions, eventData?: any): this;
    getPadding(): IPaddingOptions;
    setPadding(padding: IPaddingOptions, eventData?: any): this;
    rotateTo(bearing: number, options?: IAnimationOptions, eventData?: any): this;
    resetNorth(options?: IAnimationOptions, eventData?: any): this;
    resetNorthPitch(options?: IAnimationOptions, eventData?: any): this;
    fitBounds(bounds: LngLatBoundsLike, options?: IAnimationOptions & ICameraOptions, eventData?: any): boolean | this;
    cameraForBounds(bounds: LngLatBoundsLike, options?: ICameraOptions): void | (ICameraOptions & IAnimationOptions);
    snapToNorth(options?: IAnimationOptions, eventData?: any): this;
    jumpTo(options?: ICameraOptions, eventData?: any): boolean;
    easeTo(options?: ICameraOptions & IAnimationOptions & {
        easeId?: string;
        noMoveStart?: boolean;
    }, eventData?: any): this;
    flyTo(options?: any, eventData?: any): boolean | this;
    fitScreenCoordinates(p0: PointLike, p1: PointLike, bearing: number, options?: IAnimationOptions & ICameraOptions, eventData?: any): boolean | this;
    stop(allowGestures?: boolean, easeId?: string): this;
    renderFrameCallback: () => void;
    private normalizeBearing;
    private normalizeCenter;
    private fireMoveEvents;
    private prepareEase;
    private afterEase;
    private ease;
    private cameraForBoxAndBearing;
    private fitInternal;
}
export {};
