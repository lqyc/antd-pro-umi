import { mat2, mat4 } from 'gl-matrix';
import Point from '../geo/point';
import { IPaddingOptions } from './edge_insets';
import LngLat from './lng_lat';
import LngLatBounds from './lng_lat_bounds';
import MercatorCoordinate from './mercator';
export declare const EXTENT = 8192;
export default class Transform {
    get minZoom(): number;
    set minZoom(zoom: number);
    get maxZoom(): number;
    set maxZoom(zoom: number);
    get minPitch(): number;
    set minPitch(pitch: number);
    get maxPitch(): number;
    set maxPitch(pitch: number);
    get renderWorldCopies(): boolean;
    set renderWorldCopies(renderWorldCopies: boolean);
    get worldSize(): number;
    get centerOffset(): Point;
    get size(): Point;
    get bearing(): number;
    set bearing(bearing: number);
    get pitch(): number;
    set pitch(pitch: number);
    get fov(): number;
    set fov(fov: number);
    get zoom(): number;
    set zoom(zoom: number);
    get center(): LngLat;
    set center(center: LngLat);
    get padding(): IPaddingOptions;
    set padding(padding: IPaddingOptions);
    /**
     * The center of the screen in pixels with the top-left corner being (0,0)
     * and +y axis pointing downwards. This accounts for padding.
     *
     * @readonly
     * @type {Point}
     * @memberof Transform
     */
    get centerPoint(): Point;
    get point(): Point;
    tileSize: number;
    tileZoom: number;
    lngRange?: [number, number];
    latRange?: [number, number];
    maxValidLatitude: number;
    scale: number;
    width: number;
    height: number;
    angle: number;
    rotationMatrix: mat2;
    pixelsToGLUnits: [number, number];
    cameraToCenterDistance: number;
    mercatorMatrix: mat4;
    projMatrix: mat4;
    invProjMatrix: mat4;
    alignedProjMatrix: mat4;
    pixelMatrix: mat4;
    pixelMatrixInverse: mat4;
    glCoordMatrix: mat4;
    labelPlaneMatrix: mat4;
    private _fov;
    private _pitch;
    private _zoom;
    private _renderWorldCopies;
    private _minZoom;
    private _maxZoom;
    private _minPitch;
    private _maxPitch;
    private _center;
    private zoomFraction;
    private unmodified;
    private edgeInsets;
    private constraining;
    private posMatrixCache;
    private alignedPosMatrixCache;
    constructor(minZoom: number, maxZoom: number, minPitch: number, maxPitch: number, renderWorldCopies: boolean | void);
    clone(): Transform;
    /**
     * Returns if the padding params match
     *
     * @param {IPaddingOptions} padding
     * @returns {boolean}
     * @memberof Transform
     */
    isPaddingEqual(padding: IPaddingOptions): boolean;
    /**
     * Helper method to upadte edge-insets inplace
     *
     * @param {IPaddingOptions} target
     * @param {number} t
     * @memberof Transform
     */
    interpolatePadding(start: IPaddingOptions, target: IPaddingOptions, t: number): void;
    /**
     * Return a zoom level that will cover all tiles the transform
     * @param {Object} options options
     * @param {number} options.tileSize Tile size, expressed in screen pixels.
     * @param {boolean} options.roundZoom Target zoom level. If true, the value will be rounded to the closest integer. Otherwise the value will be floored.
     * @returns {number} zoom level An integer zoom level at which all tiles will be visible.
     */
    coveringZoomLevel(options: {
        roundZoom?: boolean;
        tileSize: number;
    }): number;
    /**
     * Return any "wrapped" copies of a given tile coordinate that are visible
     * in the current view.
     *
     * @private
     */
    /**
     * Return all coordinates that could cover this transform for a covering
     * zoom level.
     * @param {Object} options
     * @param {number} options.tileSize
     * @param {number} options.minzoom
     * @param {number} options.maxzoom
     * @param {boolean} options.roundZoom
     * @param {boolean} options.reparseOverscaled
     * @param {boolean} options.renderWorldCopies
     * @returns {Array<OverscaledTileID>} OverscaledTileIDs
     * @private
     */
    resize(width: number, height: number): void;
    zoomScale(zoom: number): number;
    scaleZoom(scale: number): number;
    project(lnglat: LngLat): Point;
    unproject(point: Point): LngLat;
    setLocationAtPoint(lnglat: LngLat, point: Point): void;
    pointCoordinate(p: Point): MercatorCoordinate;
    /**
     * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
     * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
     * @returns {LngLatBounds} Returns a {@link LngLatBounds} object describing the map's geographical bounds.
     */
    getBounds(): LngLatBounds;
    /**
     * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.
     * @returns {LngLatBounds} {@link LngLatBounds}
     */
    getMaxBounds(): LngLatBounds | null;
    /**
     * Sets or clears the map's geographical constraints.
     * @param {LngLatBounds} bounds A {@link LngLatBounds} object describing the new geographic boundaries of the map.
     */
    setMaxBounds(bounds?: LngLatBounds): void;
    customLayerMatrix(): number[];
    maxPitchScaleFactor(): number;
    getCameraPoint(): Point;
    getCameraQueryGeometry(queryGeometry: Point[]): Point[];
    /**
     * Given a coordinate, return the screen point that corresponds to it
     * @param {Coordinate} coord
     * @returns {Point} screen point
     * @private
     */
    coordinatePoint(coord: MercatorCoordinate): Point;
    /**
     * Given a location, return the screen point that corresponds to it
     * @param {LngLat} lnglat location
     * @returns {Point} screen point
     * @private
     */
    locationPoint(lnglat: LngLat): Point;
    /**
     * Given a point on screen, return its lnglat
     * @param {Point} p screen point
     * @returns {LngLat} lnglat location
     * @private
     */
    pointLocation(p: Point): LngLat;
    /**
     * Given a geographical lnglat, return an unrounded
     * coordinate that represents it at this transform's zoom level.
     * @param {LngLat} lnglat
     * @returns {Coordinate}
     * @private
     */
    locationCoordinate(lnglat: LngLat): MercatorCoordinate;
    /**
     * Given a Coordinate, return its geographical position.
     * @param {Coordinate} coord
     * @returns {LngLat} lnglat
     * @private
     */
    coordinateLocation(coord: MercatorCoordinate): LngLat;
    getProjectionMatrix(): mat4;
    /**
     * Calculate the posMatrix that, given a tile coordinate, would be used to display the tile on a map.
     * @param {UnwrappedTileID} unwrappedTileID;
     * @private
     */
    private constrain;
    private calcMatrices;
}
