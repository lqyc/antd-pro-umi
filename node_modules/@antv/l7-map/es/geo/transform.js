import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { mat2, mat4, vec3, vec4 } from 'gl-matrix';
import Point from '../geo/point';
import { clamp, interpolate, wrap } from '../util';
import EdgeInsets from './edge_insets';
import LngLat from './lng_lat';
import LngLatBounds from './lng_lat_bounds';
import MercatorCoordinate, { mercatorXfromLng, mercatorYfromLat, mercatorZfromAltitude } from './mercator';
export var EXTENT = 8192;

var Transform = function () {
  function Transform(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies) {
    _classCallCheck(this, Transform);

    this.tileSize = void 0;
    this.tileZoom = void 0;
    this.lngRange = void 0;
    this.latRange = void 0;
    this.maxValidLatitude = void 0;
    this.scale = void 0;
    this.width = void 0;
    this.height = void 0;
    this.angle = void 0;
    this.rotationMatrix = void 0;
    this.pixelsToGLUnits = void 0;
    this.cameraToCenterDistance = void 0;
    this.mercatorMatrix = void 0;
    this.projMatrix = void 0;
    this.invProjMatrix = void 0;
    this.alignedProjMatrix = void 0;
    this.pixelMatrix = void 0;
    this.pixelMatrixInverse = void 0;
    this.glCoordMatrix = void 0;
    this.labelPlaneMatrix = void 0;
    this._fov = void 0;
    this._pitch = void 0;
    this._zoom = void 0;
    this._renderWorldCopies = void 0;
    this._minZoom = void 0;
    this._maxZoom = void 0;
    this._minPitch = void 0;
    this._maxPitch = void 0;
    this._center = void 0;
    this.zoomFraction = void 0;
    this.unmodified = void 0;
    this.edgeInsets = void 0;
    this.constraining = void 0;
    this.posMatrixCache = void 0;
    this.alignedPosMatrixCache = void 0;
    this.tileSize = 512;
    this.maxValidLatitude = 85.051129;
    this._renderWorldCopies = renderWorldCopies === undefined ? true : renderWorldCopies;
    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;
    this._minPitch = minPitch === undefined || minPitch === null ? 0 : minPitch;
    this._maxPitch = maxPitch === undefined || maxPitch === null ? 60 : maxPitch;
    this.setMaxBounds();
    this.width = 0;
    this.height = 0;
    this._center = new LngLat(0, 0);
    this.zoom = 0;
    this.angle = 0;
    this._fov = 0.6435011087932844;
    this._pitch = 0;
    this.unmodified = true;
    this.edgeInsets = new EdgeInsets();
    this.posMatrixCache = {};
    this.alignedPosMatrixCache = {};
  }

  _createClass(Transform, [{
    key: "minZoom",
    get: function get() {
      return this._minZoom;
    },
    set: function set(zoom) {
      if (this._minZoom === zoom) {
        return;
      }

      this._minZoom = zoom;
      this.zoom = Math.max(this.zoom, zoom);
    }
  }, {
    key: "maxZoom",
    get: function get() {
      return this._maxZoom;
    },
    set: function set(zoom) {
      if (this._maxZoom === zoom) {
        return;
      }

      this._maxZoom = zoom;
      this.zoom = Math.min(this.zoom, zoom);
    }
  }, {
    key: "minPitch",
    get: function get() {
      return this._minPitch;
    },
    set: function set(pitch) {
      if (this._minPitch === pitch) {
        return;
      }

      this._minPitch = pitch;
      this._pitch = Math.max(this._pitch, pitch);
    }
  }, {
    key: "maxPitch",
    get: function get() {
      return this._maxPitch;
    },
    set: function set(pitch) {
      if (this._maxPitch === pitch) {
        return;
      }

      this._maxPitch = pitch;
      this._pitch = Math.min(this._pitch, pitch);
    }
  }, {
    key: "renderWorldCopies",
    get: function get() {
      return this._renderWorldCopies;
    },
    set: function set(renderWorldCopies) {
      if (renderWorldCopies === undefined) {
        renderWorldCopies = true;
      } else if (renderWorldCopies === null) {
        renderWorldCopies = false;
      }

      this._renderWorldCopies = renderWorldCopies;
    }
  }, {
    key: "worldSize",
    get: function get() {
      return this.tileSize * this.scale;
    }
  }, {
    key: "centerOffset",
    get: function get() {
      return this.centerPoint._sub(this.size._div(2));
    }
  }, {
    key: "size",
    get: function get() {
      return new Point(this.width, this.height);
    }
  }, {
    key: "bearing",
    get: function get() {
      return -this.angle / Math.PI * 180;
    },
    set: function set(bearing) {
      var b = -wrap(bearing, -180, 180) * Math.PI / 180;

      if (this.angle === b) {
        return;
      }

      this.unmodified = false;
      this.angle = b;
      this.calcMatrices();
      this.rotationMatrix = mat2.create();
      mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
    }
  }, {
    key: "pitch",
    get: function get() {
      return this._pitch / Math.PI * 180;
    },
    set: function set(pitch) {
      var p = clamp(pitch, this._minPitch, this._maxPitch) / 180 * Math.PI;

      if (this._pitch === p) {
        return;
      }

      this.unmodified = false;
      this._pitch = p;
      this.calcMatrices();
    }
  }, {
    key: "fov",
    get: function get() {
      return this._fov / Math.PI * 180;
    },
    set: function set(fov) {
      fov = Math.max(0.01, Math.min(60, fov));

      if (this._fov === fov) {
        return;
      }

      this.unmodified = false;
      this._fov = fov / 180 * Math.PI;
      this.calcMatrices();
    }
  }, {
    key: "zoom",
    get: function get() {
      return this._zoom;
    },
    set: function set(zoom) {
      var z = Math.min(Math.max(zoom, this._minZoom), this._maxZoom);

      if (this._zoom === z) {
        return;
      }

      this.unmodified = false;
      this._zoom = z;
      this.scale = this.zoomScale(z);
      this.tileZoom = Math.floor(z);
      this.zoomFraction = z - this.tileZoom;
      this.constrain();
      this.calcMatrices();
    }
  }, {
    key: "center",
    get: function get() {
      return this._center;
    },
    set: function set(center) {
      if (center.lat === this._center.lat && center.lng === this._center.lng) {
        return;
      }

      this.unmodified = false;
      this._center = center;
      this.constrain();
      this.calcMatrices();
    }
  }, {
    key: "padding",
    get: function get() {
      return this.edgeInsets.toJSON();
    },
    set: function set(padding) {
      if (this.edgeInsets.equals(padding)) {
        return;
      }

      this.unmodified = false;
      this.edgeInsets.interpolate(this.edgeInsets, padding, 1);
      this.calcMatrices();
    }
  }, {
    key: "centerPoint",
    get: function get() {
      return this.edgeInsets.getCenter(this.width, this.height);
    }
  }, {
    key: "point",
    get: function get() {
      return this.project(this.center);
    }
  }, {
    key: "clone",
    value: function clone() {
      var clone = new Transform(this._minZoom, this._maxZoom, this._minPitch, this._maxPitch, this._renderWorldCopies);
      clone.tileSize = this.tileSize;
      clone.latRange = this.latRange;
      clone.width = this.width;
      clone.height = this.height;
      clone.center = this._center;
      clone.zoom = this.zoom;
      clone.angle = this.angle;
      clone.fov = this._fov;
      clone.pitch = this._pitch;
      clone.unmodified = this.unmodified;
      clone.edgeInsets = this.edgeInsets.clone();
      clone.calcMatrices();
      return clone;
    }
  }, {
    key: "isPaddingEqual",
    value: function isPaddingEqual(padding) {
      return this.edgeInsets.equals(padding);
    }
  }, {
    key: "interpolatePadding",
    value: function interpolatePadding(start, target, t) {
      this.unmodified = false;
      this.edgeInsets.interpolate(start, target, t);
      this.constrain();
      this.calcMatrices();
    }
  }, {
    key: "coveringZoomLevel",
    value: function coveringZoomLevel(options) {
      var z = (options.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / options.tileSize));
      return Math.max(0, z);
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      this.width = width;
      this.height = height;
      this.pixelsToGLUnits = [2 / width, -2 / height];
      this.constrain();
      this.calcMatrices();
    }
  }, {
    key: "zoomScale",
    value: function zoomScale(zoom) {
      return Math.pow(2, zoom);
    }
  }, {
    key: "scaleZoom",
    value: function scaleZoom(scale) {
      return Math.log(scale) / Math.LN2;
    }
  }, {
    key: "project",
    value: function project(lnglat) {
      var lat = clamp(lnglat.lat, -this.maxValidLatitude, this.maxValidLatitude);
      return new Point(mercatorXfromLng(lnglat.lng) * this.worldSize, mercatorYfromLat(lat) * this.worldSize);
    }
  }, {
    key: "unproject",
    value: function unproject(point) {
      return new MercatorCoordinate(point.x / this.worldSize, point.y / this.worldSize).toLngLat();
    }
  }, {
    key: "setLocationAtPoint",
    value: function setLocationAtPoint(lnglat, point) {
      var a = this.pointCoordinate(point);
      var b = this.pointCoordinate(this.centerPoint);
      var loc = this.locationCoordinate(lnglat);
      var newCenter = new MercatorCoordinate(loc.x - (a.x - b.x), loc.y - (a.y - b.y));
      this.center = this.coordinateLocation(newCenter);

      if (this._renderWorldCopies) {
        this.center = this.center.wrap();
      }
    }
  }, {
    key: "pointCoordinate",
    value: function pointCoordinate(p) {
      var targetZ = 0;
      var coord0 = new Float32Array([p.x, p.y, 0, 1]);
      var coord1 = new Float32Array([p.x, p.y, 1, 1]);
      vec4.transformMat4(coord0, coord0, this.pixelMatrixInverse);
      vec4.transformMat4(coord1, coord1, this.pixelMatrixInverse);
      var w0 = coord0[3];
      var w1 = coord1[3];
      var x0 = coord0[0] / w0;
      var x1 = coord1[0] / w1;
      var y0 = coord0[1] / w0;
      var y1 = coord1[1] / w1;
      var z0 = coord0[2] / w0;
      var z1 = coord1[2] / w1;
      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      return new MercatorCoordinate(interpolate(x0, x1, t) / this.worldSize, interpolate(y0, y1, t) / this.worldSize);
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      return new LngLatBounds().extend(this.pointLocation(new Point(0, 0))).extend(this.pointLocation(new Point(this.width, 0))).extend(this.pointLocation(new Point(this.width, this.height))).extend(this.pointLocation(new Point(0, this.height)));
    }
  }, {
    key: "getMaxBounds",
    value: function getMaxBounds() {
      if (!this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2) {
        return null;
      }

      return new LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);
    }
  }, {
    key: "setMaxBounds",
    value: function setMaxBounds(bounds) {
      if (bounds) {
        this.lngRange = [bounds.getWest(), bounds.getEast()];
        this.latRange = [bounds.getSouth(), bounds.getNorth()];
        this.constrain();
      } else {
        this.lngRange = undefined;
        this.latRange = [-this.maxValidLatitude, this.maxValidLatitude];
      }
    }
  }, {
    key: "customLayerMatrix",
    value: function customLayerMatrix() {
      return this.mercatorMatrix.slice();
    }
  }, {
    key: "maxPitchScaleFactor",
    value: function maxPitchScaleFactor() {
      if (!this.pixelMatrixInverse) {
        return 1;
      }

      var coord = this.pointCoordinate(new Point(0, 0));
      var p = new Float32Array([coord.x * this.worldSize, coord.y * this.worldSize, 0, 1]);
      var topPoint = vec4.transformMat4(p, p, this.pixelMatrix);
      return topPoint[3] / this.cameraToCenterDistance;
    }
  }, {
    key: "getCameraPoint",
    value: function getCameraPoint() {
      var pitch = this._pitch;
      var yOffset = Math.tan(pitch) * (this.cameraToCenterDistance || 1);
      return this.centerPoint.add(new Point(0, yOffset));
    }
  }, {
    key: "getCameraQueryGeometry",
    value: function getCameraQueryGeometry(queryGeometry) {
      var c = this.getCameraPoint();

      if (queryGeometry.length === 1) {
        return [queryGeometry[0], c];
      } else {
        var minX = c.x;
        var minY = c.y;
        var maxX = c.x;
        var maxY = c.y;

        var _iterator = _createForOfIteratorHelper(queryGeometry),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var p = _step.value;
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return [new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY), new Point(minX, minY)];
      }
    }
  }, {
    key: "coordinatePoint",
    value: function coordinatePoint(coord) {
      var p = vec4.fromValues(coord.x * this.worldSize, coord.y * this.worldSize, 0, 1);
      vec4.transformMat4(p, p, this.pixelMatrix);
      return new Point(p[0] / p[3], p[1] / p[3]);
    }
  }, {
    key: "locationPoint",
    value: function locationPoint(lnglat) {
      return this.coordinatePoint(this.locationCoordinate(lnglat));
    }
  }, {
    key: "pointLocation",
    value: function pointLocation(p) {
      return this.coordinateLocation(this.pointCoordinate(p));
    }
  }, {
    key: "locationCoordinate",
    value: function locationCoordinate(lnglat) {
      return MercatorCoordinate.fromLngLat(lnglat);
    }
  }, {
    key: "coordinateLocation",
    value: function coordinateLocation(coord) {
      return coord.toLngLat();
    }
  }, {
    key: "getProjectionMatrix",
    value: function getProjectionMatrix() {
      return this.projMatrix;
    }
  }, {
    key: "constrain",
    value: function constrain() {
      if (!this.center || !this.width || !this.height || this.constraining) {
        return;
      }

      this.constraining = true;
      var minY = -90;
      var maxY = 90;
      var minX = -180;
      var maxX = 180;
      var sy;
      var sx;
      var x2;
      var y2;
      var size = this.size;
      var unmodified = this.unmodified;

      if (this.latRange) {
        var latRange = this.latRange;
        minY = mercatorYfromLat(latRange[1]) * this.worldSize;
        maxY = mercatorYfromLat(latRange[0]) * this.worldSize;
        sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
      }

      if (this.lngRange) {
        var lngRange = this.lngRange;
        minX = mercatorXfromLng(lngRange[0]) * this.worldSize;
        maxX = mercatorXfromLng(lngRange[1]) * this.worldSize;
        sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
      }

      var point = this.point;
      var s = Math.max(sx || 0, sy || 0);

      if (s) {
        this.center = this.unproject(new Point(sx ? (maxX + minX) / 2 : point.x, sy ? (maxY + minY) / 2 : point.y));
        this.zoom += this.scaleZoom(s);
        this.unmodified = unmodified;
        this.constraining = false;
        return;
      }

      if (this.latRange) {
        var y = point.y;
        var h2 = size.y / 2;

        if (y - h2 < minY) {
          y2 = minY + h2;
        }

        if (y + h2 > maxY) {
          y2 = maxY - h2;
        }
      }

      if (this.lngRange) {
        var x = point.x;
        var w2 = size.x / 2;

        if (x - w2 < minX) {
          x2 = minX + w2;
        }

        if (x + w2 > maxX) {
          x2 = maxX - w2;
        }
      }

      if (x2 !== undefined || y2 !== undefined) {
        this.center = this.unproject(new Point(x2 !== undefined ? x2 : point.x, y2 !== undefined ? y2 : point.y));
      }

      this.unmodified = unmodified;
      this.constraining = false;
    }
  }, {
    key: "calcMatrices",
    value: function calcMatrices() {
      if (!this.height) {
        return;
      }

      var halfFov = this._fov / 2;
      var offset = this.centerOffset;
      this.cameraToCenterDistance = 0.5 / Math.tan(halfFov) * this.height;
      var groundAngle = Math.PI / 2 + this._pitch;
      var fovAboveCenter = this._fov * (0.5 + offset.y / this.height);
      var topHalfSurfaceDistance = Math.sin(fovAboveCenter) * this.cameraToCenterDistance / Math.sin(clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));
      var point = this.point;
      var x = point.x;
      var y = point.y;
      var furthestDistance = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.cameraToCenterDistance;
      var farZ = furthestDistance * 1.01;
      var nearZ = this.height / 50;
      var m = mat4.create();
      mat4.perspective(m, this._fov, this.width / this.height, nearZ, farZ);
      m[8] = -offset.x * 2 / this.width;
      m[9] = offset.y * 2 / this.height;
      mat4.scale(m, m, [1, -1, 1]);
      mat4.translate(m, m, [0, 0, -this.cameraToCenterDistance]);
      mat4.rotateX(m, m, this._pitch);
      mat4.rotateZ(m, m, this.angle);
      mat4.translate(m, m, [-x, -y, 0]);
      this.mercatorMatrix = mat4.scale(mat4.create(), m, [this.worldSize, this.worldSize, this.worldSize]);
      mat4.scale(m, m, vec3.fromValues(1, 1, mercatorZfromAltitude(1, this.center.lat) * this.worldSize));
      this.projMatrix = m;
      this.invProjMatrix = mat4.invert(mat4.create(), this.projMatrix);
      var xShift = this.width % 2 / 2;
      var yShift = this.height % 2 / 2;
      var angleCos = Math.cos(this.angle);
      var angleSin = Math.sin(this.angle);
      var dx = x - Math.round(x) + angleCos * xShift + angleSin * yShift;
      var dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;
      var alignedM = mat4.clone(m);
      mat4.translate(alignedM, alignedM, [dx > 0.5 ? dx - 1 : dx, dy > 0.5 ? dy - 1 : dy, 0]);
      this.alignedProjMatrix = alignedM;
      m = mat4.create();
      mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
      mat4.translate(m, m, [1, -1, 0]);
      this.labelPlaneMatrix = m;
      m = mat4.create();
      mat4.scale(m, m, [1, -1, 1]);
      mat4.translate(m, m, [-1, -1, 0]);
      mat4.scale(m, m, [2 / this.width, 2 / this.height, 1]);
      this.glCoordMatrix = m;
      this.pixelMatrix = mat4.multiply(mat4.create(), this.labelPlaneMatrix, this.projMatrix);
      m = mat4.invert(mat4.create(), this.pixelMatrix);

      if (!m) {
        throw new Error('failed to invert matrix');
      }

      this.pixelMatrixInverse = m;
      this.posMatrixCache = {};
      this.alignedPosMatrixCache = {};
    }
  }]);

  return Transform;
}();

export { Transform as default };
//# sourceMappingURL=transform.js.map