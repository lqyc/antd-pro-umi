import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _merge from "lodash/merge";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { EventEmitter } from 'eventemitter3';
import LngLat from './geo/lng_lat';
import LngLatBounds from './geo/lng_lat_bounds';
import Point from './geo/point';
import Transform from './geo/transform';
import { Event } from './handler/events/event';
import { clamp, ease as defaultEasing, interpolate, now, pick, prefersReducedMotion, wrap } from './util';

var Camera = function (_EventEmitter) {
  _inherits(Camera, _EventEmitter);

  var _super = _createSuper(Camera);

  function Camera(options) {
    var _this;

    _classCallCheck(this, Camera);

    _this = _super.call(this);
    _this.transform = void 0;
    _this.options = void 0;
    _this.moving = void 0;
    _this.zooming = void 0;
    _this.rotating = void 0;
    _this.pitching = void 0;
    _this.padding = void 0;
    _this.bearingSnap = void 0;
    _this.easeEndTimeoutID = void 0;
    _this.easeStart = void 0;
    _this.easeOptions = void 0;
    _this.easeId = void 0;
    _this.onEaseFrame = void 0;
    _this.onEaseEnd = void 0;
    _this.easeFrameId = void 0;

    _this.renderFrameCallback = function () {
      var t = Math.min((now() - _this.easeStart) / _this.easeOptions.duration, 1);

      _this.onEaseFrame(_this.easeOptions.easing(t));

      if (t < 1) {
        _this.easeFrameId = _this.requestRenderFrame(_this.renderFrameCallback);
      } else {
        _this.stop();
      }
    };

    _this.options = options;
    var minZoom = options.minZoom,
        maxZoom = options.maxZoom,
        minPitch = options.minPitch,
        maxPitch = options.maxPitch,
        renderWorldCopies = options.renderWorldCopies;
    _this.moving = false;
    _this.zooming = false;
    _this.bearingSnap = options.bearingSnap;
    _this.transform = new Transform(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies);
    return _this;
  }

  _createClass(Camera, [{
    key: "requestRenderFrame",
    value: function requestRenderFrame(cb) {
      return 0;
    }
  }, {
    key: "cancelRenderFrame",
    value: function cancelRenderFrame(_) {
      return;
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      var _this$transform$cente = this.transform.center,
          lng = _this$transform$cente.lng,
          lat = _this$transform$cente.lat;
      return new LngLat(lng, lat);
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.transform.zoom;
    }
  }, {
    key: "getPitch",
    value: function getPitch() {
      return this.transform.pitch;
    }
  }, {
    key: "setCenter",
    value: function setCenter(center, eventData) {
      return this.jumpTo({
        center: center
      }, eventData);
    }
  }, {
    key: "setPitch",
    value: function setPitch(pitch, eventData) {
      this.jumpTo({
        pitch: pitch
      }, eventData);
      return this;
    }
  }, {
    key: "getBearing",
    value: function getBearing() {
      return this.transform.bearing;
    }
  }, {
    key: "panTo",
    value: function panTo(lnglat, options, eventData) {
      return this.easeTo(_merge({
        center: lnglat
      }, options), eventData);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut(options, eventData) {
      this.zoomTo(this.getZoom() - 1, options, eventData);
      return this;
    }
  }, {
    key: "setBearing",
    value: function setBearing(bearing, eventData) {
      this.jumpTo({
        bearing: bearing
      }, eventData);
      return this;
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom, eventData) {
      this.jumpTo({
        zoom: zoom
      }, eventData);
      return this;
    }
  }, {
    key: "zoomIn",
    value: function zoomIn(options, eventData) {
      this.zoomTo(this.getZoom() + 1, options, eventData);
      return this;
    }
  }, {
    key: "zoomTo",
    value: function zoomTo(zoom, options, eventData) {
      return this.easeTo(_merge({
        zoom: zoom
      }, options), eventData);
    }
  }, {
    key: "getPadding",
    value: function getPadding() {
      return this.transform.padding;
    }
  }, {
    key: "setPadding",
    value: function setPadding(padding, eventData) {
      this.jumpTo({
        padding: padding
      }, eventData);
      return this;
    }
  }, {
    key: "rotateTo",
    value: function rotateTo(bearing, options, eventData) {
      return this.easeTo(_merge({
        bearing: bearing
      }, options), eventData);
    }
  }, {
    key: "resetNorth",
    value: function resetNorth(options, eventData) {
      this.rotateTo(0, _merge({
        duration: 1000
      }, options), eventData);
      return this;
    }
  }, {
    key: "resetNorthPitch",
    value: function resetNorthPitch(options, eventData) {
      this.easeTo(_merge({
        bearing: 0,
        pitch: 0,
        duration: 1000
      }, options), eventData);
      return this;
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bounds, options, eventData) {
      return this.fitInternal(this.cameraForBounds(bounds, options), options, eventData);
    }
  }, {
    key: "cameraForBounds",
    value: function cameraForBounds(bounds, options) {
      bounds = LngLatBounds.convert(bounds);
      return this.cameraForBoxAndBearing(bounds.getNorthWest(), bounds.getSouthEast(), 0, options);
    }
  }, {
    key: "snapToNorth",
    value: function snapToNorth(options, eventData) {
      if (Math.abs(this.getBearing()) < this.bearingSnap) {
        return this.resetNorth(options, eventData);
      }

      return this;
    }
  }, {
    key: "jumpTo",
    value: function jumpTo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var eventData = arguments.length > 1 ? arguments[1] : undefined;
      this.stop();
      var tr = this.transform;
      var zoomChanged = false;
      var bearingChanged = false;
      var pitchChanged = false;

      if (options.zoom && tr.zoom !== +options.zoom) {
        zoomChanged = true;
        tr.zoom = +options.zoom;
      }

      if (options.center !== undefined) {
        tr.center = LngLat.convert(options.center);
      }

      if (options.bearing && tr.bearing !== +options.bearing) {
        bearingChanged = true;
        tr.bearing = +options.bearing;
      }

      if (options.pitch && tr.pitch !== +options.pitch) {
        pitchChanged = true;
        tr.pitch = +options.pitch;
      }

      if (options.padding != null && !tr.isPaddingEqual(options.padding)) {
        tr.padding = options.padding;
      }

      this.emit('movestart', new Event('movestart', eventData));
      this.emit('move', new Event('move', eventData));

      if (zoomChanged) {
        this.emit('zoomstart', new Event('zoomstart', eventData));
        this.emit('zoom', new Event('zoom', eventData));
        this.emit('zoomend', new Event('zoomend', eventData));
      }

      if (bearingChanged) {
        this.emit('rotatestart', new Event('rotatestart', eventData));
        this.emit('rotate', new Event('rotate', eventData));
        this.emit('rotateend', new Event('rotateend', eventData));
      }

      if (pitchChanged) {
        this.emit('pitchstart', new Event('pitchstart', eventData));
        this.emit('pitch', new Event('pitch', eventData));
        this.emit('pitchend', new Event('pitchend', eventData));
      }

      return this.emit('moveend', new Event('moveend', eventData));
    }
  }, {
    key: "easeTo",
    value: function easeTo() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var eventData = arguments.length > 1 ? arguments[1] : undefined;
      options = _merge({
        offset: [0, 0],
        duration: 500,
        easing: defaultEasing
      }, options);

      if (options.animate === false || !options.essential && prefersReducedMotion()) {
        options.duration = 0;
      }

      var tr = this.transform;
      var startZoom = this.getZoom();
      var startBearing = this.getBearing();
      var startPitch = this.getPitch();
      var startPadding = this.getPadding();
      var zoom = options.zoom ? +options.zoom : startZoom;
      var bearing = options.bearing ? this.normalizeBearing(options.bearing, startBearing) : startBearing;
      var pitch = options.pitch ? +options.pitch : startPitch;
      var padding = options.padding ? options.padding : tr.padding;
      var offsetAsPoint = Point.convert(options.offset);
      var pointAtOffset = tr.centerPoint.add(offsetAsPoint);
      var locationAtOffset = tr.pointLocation(pointAtOffset);
      var center = LngLat.convert(options.center || locationAtOffset);
      this.normalizeCenter(center);
      var from = tr.project(locationAtOffset);
      var delta = tr.project(center).sub(from);
      var finalScale = tr.zoomScale(zoom - startZoom);
      var around;
      var aroundPoint;

      if (options.around) {
        around = LngLat.convert(options.around);
        aroundPoint = tr.locationPoint(around);
      }

      var currently = {
        moving: this.moving,
        zooming: this.zooming,
        rotating: this.rotating,
        pitching: this.pitching
      };
      this.zooming = this.zooming || zoom !== startZoom;
      this.rotating = this.rotating || startBearing !== bearing;
      this.pitching = this.pitching || pitch !== startPitch;
      this.padding = !tr.isPaddingEqual(padding);
      this.easeId = options.easeId;
      this.prepareEase(eventData, options.noMoveStart, currently);
      clearTimeout(this.easeEndTimeoutID);
      this.ease(function (k) {
        if (_this2.zooming) {
          tr.zoom = interpolate(startZoom, zoom, k);
        }

        if (_this2.rotating) {
          tr.bearing = interpolate(startBearing, bearing, k);
        }

        if (_this2.pitching) {
          tr.pitch = interpolate(startPitch, pitch, k);
        }

        if (_this2.padding) {
          tr.interpolatePadding(startPadding, padding, k);
          pointAtOffset = tr.centerPoint.add(offsetAsPoint);
        }

        if (around) {
          tr.setLocationAtPoint(around, aroundPoint);
        } else {
          var scale = tr.zoomScale(tr.zoom - startZoom);
          var base = zoom > startZoom ? Math.min(2, finalScale) : Math.max(0.5, finalScale);
          var speedup = Math.pow(base, 1 - k);
          var newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale));
          tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
        }

        _this2.fireMoveEvents(eventData);
      }, function (interruptingEaseId) {
        _this2.afterEase(eventData, interruptingEaseId);
      }, options);
      return this;
    }
  }, {
    key: "flyTo",
    value: function flyTo() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var eventData = arguments.length > 1 ? arguments[1] : undefined;

      if (!options.essential && prefersReducedMotion()) {
        var coercedOptions = pick(options, ['center', 'zoom', 'bearing', 'pitch', 'around']);
        return this.jumpTo(coercedOptions, eventData);
      }

      this.stop();
      options = _merge({
        offset: [0, 0],
        speed: 1.2,
        curve: 1.42,
        easing: defaultEasing
      }, options);
      var tr = this.transform;
      var startZoom = this.getZoom();
      var startBearing = this.getBearing();
      var startPitch = this.getPitch();
      var startPadding = this.getPadding();
      var zoom = options.zoom ? clamp(+options.zoom, tr.minZoom, tr.maxZoom) : startZoom;
      var bearing = options.bearing ? this.normalizeBearing(options.bearing, startBearing) : startBearing;
      var pitch = options.pitch ? +options.pitch : startPitch;
      var padding = 'padding' in options ? options.padding : tr.padding;
      var scale = tr.zoomScale(zoom - startZoom);
      var offsetAsPoint = Point.convert(options.offset);
      var pointAtOffset = tr.centerPoint.add(offsetAsPoint);
      var locationAtOffset = tr.pointLocation(pointAtOffset);
      var center = LngLat.convert(options.center || locationAtOffset);
      this.normalizeCenter(center);
      var from = tr.project(locationAtOffset);
      var delta = tr.project(center).sub(from);
      var rho = options.curve;
      var w0 = Math.max(tr.width, tr.height);
      var w1 = w0 / scale;
      var u1 = delta.mag();

      if ('minZoom' in options) {
        var minZoom = clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
        var wMax = w0 / tr.zoomScale(minZoom - startZoom);
        rho = Math.sqrt(wMax / u1 * 2);
      }

      var rho2 = rho * rho;

      function r(i) {
        var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
        return Math.log(Math.sqrt(b * b + 1) - b);
      }

      function sinh(n) {
        return (Math.exp(n) - Math.exp(-n)) / 2;
      }

      function cosh(n) {
        return (Math.exp(n) + Math.exp(-n)) / 2;
      }

      function tanh(n) {
        return sinh(n) / cosh(n);
      }

      var r0 = r(0);

      var w = function w(s) {
        return cosh(r0) / cosh(r0 + rho * s);
      };

      var u = function u(s) {
        return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;
      };

      var S = (r(1) - r0) / rho;

      if (Math.abs(u1) < 0.000001 || !isFinite(S)) {
        if (Math.abs(w0 - w1) < 0.000001) {
          return this.easeTo(options, eventData);
        }

        var k = w1 < w0 ? -1 : 1;
        S = Math.abs(Math.log(w1 / w0)) / rho;

        u = function u() {
          return 0;
        };

        w = function w(s) {
          return Math.exp(k * rho * s);
        };
      }

      if ('duration' in options) {
        options.duration = +options.duration;
      } else {
        var V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
        options.duration = 1000 * S / V;
      }

      if (options.maxDuration && options.duration > options.maxDuration) {
        options.duration = 0;
      }

      this.zooming = true;
      this.rotating = startBearing !== bearing;
      this.pitching = pitch !== startPitch;
      this.padding = !tr.isPaddingEqual(padding);
      this.prepareEase(eventData, false);
      this.ease(function (k) {
        var s = k * S;
        var easeScale = 1 / w(s);
        tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(easeScale);

        if (_this3.rotating) {
          tr.bearing = interpolate(startBearing, bearing, k);
        }

        if (_this3.pitching) {
          tr.pitch = interpolate(startPitch, pitch, k);
        }

        if (_this3.padding) {
          tr.interpolatePadding(startPadding, padding, k);
          pointAtOffset = tr.centerPoint.add(offsetAsPoint);
        }

        var newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(easeScale));
        tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);

        _this3.fireMoveEvents(eventData);
      }, function () {
        return _this3.afterEase(eventData);
      }, options);
      return this;
    }
  }, {
    key: "fitScreenCoordinates",
    value: function fitScreenCoordinates(p0, p1, bearing, options, eventData) {
      return this.fitInternal(this.cameraForBoxAndBearing(this.transform.pointLocation(Point.convert(p0)), this.transform.pointLocation(Point.convert(p1)), bearing, options), options, eventData);
    }
  }, {
    key: "stop",
    value: function stop(allowGestures, easeId) {
      if (this.easeFrameId) {
        this.cancelRenderFrame(this.easeFrameId);
        delete this.easeFrameId;
        delete this.onEaseFrame;
      }

      if (this.onEaseEnd) {
        var onEaseEnd = this.onEaseEnd;
        delete this.onEaseEnd;
        onEaseEnd.call(this, easeId);
      }

      return this;
    }
  }, {
    key: "normalizeBearing",
    value: function normalizeBearing(bearing, currentBearing) {
      bearing = wrap(bearing, -180, 180);
      var diff = Math.abs(bearing - currentBearing);

      if (Math.abs(bearing - 360 - currentBearing) < diff) {
        bearing -= 360;
      }

      if (Math.abs(bearing + 360 - currentBearing) < diff) {
        bearing += 360;
      }

      return bearing;
    }
  }, {
    key: "normalizeCenter",
    value: function normalizeCenter(center) {
      var tr = this.transform;

      if (!tr.renderWorldCopies || tr.lngRange) {
        return;
      }

      var delta = center.lng - tr.center.lng;
      center.lng += delta > 180 ? -360 : delta < -180 ? 360 : 0;
    }
  }, {
    key: "fireMoveEvents",
    value: function fireMoveEvents(eventData) {
      this.emit('move', new Event('move', eventData));

      if (this.zooming) {
        this.emit('zoom', new Event('zoom', eventData));
      }

      if (this.rotating) {
        this.emit('rotate', new Event('rotate', eventData));
      }

      if (this.pitching) {
        this.emit('rotate', new Event('pitch', eventData));
      }
    }
  }, {
    key: "prepareEase",
    value: function prepareEase(eventData) {
      var noMoveStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var currently = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.moving = true;

      if (!noMoveStart && !currently.moving) {
        this.emit('movestart', new Event('movestart', eventData));
      }

      if (this.zooming && !currently.zooming) {
        this.emit('zoomstart', new Event('zoomstart', eventData));
      }

      if (this.rotating && !currently.rotating) {
        this.emit('rotatestart', new Event('rotatestart', eventData));
      }

      if (this.pitching && !currently.pitching) {
        this.emit('pitchstart', new Event('pitchstart', eventData));
      }
    }
  }, {
    key: "afterEase",
    value: function afterEase(eventData, easeId) {
      if (this.easeId && easeId && this.easeId === easeId) {
        return;
      }

      delete this.easeId;
      var wasZooming = this.zooming;
      var wasRotating = this.rotating;
      var wasPitching = this.pitching;
      this.moving = false;
      this.zooming = false;
      this.rotating = false;
      this.pitching = false;
      this.padding = false;

      if (wasZooming) {
        this.emit('zoomend', new Event('zoomend', eventData));
      }

      if (wasRotating) {
        this.emit('rotateend', new Event('rotateend', eventData));
      }

      if (wasPitching) {
        this.emit('pitchend', new Event('pitchend', eventData));
      }

      this.emit('moveend', new Event('moveend', eventData));
    }
  }, {
    key: "ease",
    value: function ease(frame, finish, options) {
      if (options.animate === false || options.duration === 0) {
        frame(1);
        finish();
      } else {
        this.easeStart = now();
        this.easeOptions = options;
        this.onEaseFrame = frame;
        this.onEaseEnd = finish;
        this.easeFrameId = this.requestRenderFrame(this.renderFrameCallback);
      }
    }
  }, {
    key: "cameraForBoxAndBearing",
    value: function cameraForBoxAndBearing(p0, p1, bearing, options) {
      var defaultPadding = {
        top: 0,
        bottom: 0,
        right: 0,
        left: 0
      };
      options = _merge({
        padding: defaultPadding,
        offset: [0, 0],
        maxZoom: this.transform.maxZoom
      }, options);

      if (typeof options.padding === 'number') {
        var p = options.padding;
        options.padding = {
          top: p,
          bottom: p,
          right: p,
          left: p
        };
      }

      options.padding = _merge(defaultPadding, options.padding);
      var tr = this.transform;
      var edgePadding = tr.padding;
      var p0world = tr.project(LngLat.convert(p0));
      var p1world = tr.project(LngLat.convert(p1));
      var p0rotated = p0world.rotate(-bearing * Math.PI / 180);
      var p1rotated = p1world.rotate(-bearing * Math.PI / 180);
      var upperRight = new Point(Math.max(p0rotated.x, p1rotated.x), Math.max(p0rotated.y, p1rotated.y));
      var lowerLeft = new Point(Math.min(p0rotated.x, p1rotated.x), Math.min(p0rotated.y, p1rotated.y));
      var size = upperRight.sub(lowerLeft);
      var scaleX = (tr.width - (edgePadding.left + edgePadding.right + options.padding.left + options.padding.right)) / size.x;
      var scaleY = (tr.height - (edgePadding.top + edgePadding.bottom + options.padding.top + options.padding.bottom)) / size.y;

      if (scaleY < 0 || scaleX < 0) {
        return;
      }

      var zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
      var offset = Point.convert(options.offset);
      var paddingOffsetX = (options.padding.left - options.padding.right) / 2;
      var paddingOffsetY = (options.padding.top - options.padding.bottom) / 2;
      var offsetAtInitialZoom = new Point(offset.x + paddingOffsetX, offset.y + paddingOffsetY);
      var offsetAtFinalZoom = offsetAtInitialZoom.mult(tr.scale / tr.zoomScale(zoom));
      var center = tr.unproject(p0world.add(p1world).div(2).sub(offsetAtFinalZoom));
      return {
        center: center,
        zoom: zoom,
        bearing: bearing
      };
    }
  }, {
    key: "fitInternal",
    value: function fitInternal(calculatedOptions, options, eventData) {
      if (!calculatedOptions) {
        return this;
      }

      options = _merge(calculatedOptions, options);
      delete options.padding;
      return options.linear ? this.easeTo(options, eventData) : this.flyTo(options, eventData);
    }
  }]);

  return Camera;
}(EventEmitter);

export { Camera as default };
//# sourceMappingURL=camera.js.map