import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { degreesToRadians, radiansToLength } from '@turf/helpers';
var originShift = 2 * Math.PI * 6378137 / 2.0;
export function extent(data) {
  var dataExtent = [Infinity, Infinity, -Infinity, -Infinity];
  data.forEach(function (item) {
    var coordinates = item.coordinates;
    caculExtent(dataExtent, coordinates);
  });
  return dataExtent;
}

function caculExtent(dataExtent, coords) {
  if (Array.isArray(coords[0])) {
    coords.forEach(function (coord) {
      caculExtent(dataExtent, coord);
    });
  } else {
    if (dataExtent[0] > coords[0]) {
      dataExtent[0] = coords[0];
    }

    if (dataExtent[1] > coords[1]) {
      dataExtent[1] = coords[1];
    }

    if (dataExtent[2] < coords[0]) {
      dataExtent[2] = coords[0];
    }

    if (dataExtent[3] < coords[1]) {
      dataExtent[3] = coords[1];
    }
  }

  return dataExtent;
}

export function tranfrormCoord(data, cb) {
  return transform(data, cb);
}

function transform(item, cb) {
  if (Array.isArray(item[0])) {
    return item.map(function (coord) {
      return transform(coord, cb);
    });
  }

  return cb(item);
}

export function lngLatToMeters(lnglat) {
  var validate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    enable: true,
    decimal: 1
  };
  lnglat = validateLngLat(lnglat, validate);
  var lng = lnglat[0];
  var lat = lnglat[1];
  var x = lng * originShift / 180.0;
  var y = Math.log(Math.tan((90 + lat) * Math.PI / 360.0)) / (Math.PI / 180.0);
  y = y * originShift / 180.0;

  if (accuracy.enable) {
    x = Number(x.toFixed(accuracy.decimal));
    y = Number(y.toFixed(accuracy.decimal));
  }

  return lnglat.length === 3 ? [x, y, lnglat[2]] : [x, y];
}
export function metersToLngLat(meters) {
  var decimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
  var x = meters[0];
  var y = meters[1];
  var lng = x / originShift * 180.0;
  var lat = y / originShift * 180.0;
  lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180.0)) - Math.PI / 2.0);

  if (decimal !== undefined && decimal !== null) {
    lng = Number(lng.toFixed(decimal));
    lat = Number(lat.toFixed(decimal));
  }

  return meters.length === 3 ? [lng, lat, meters[2]] : [lng, lat];
}
export function longitude(lng) {
  if (lng === undefined || lng === null) {
    throw new Error('lng is required');
  }

  if (lng > 180 || lng < -180) {
    lng = lng % 360;

    if (lng > 180) {
      lng = -360 + lng;
    }

    if (lng < -180) {
      lng = 360 + lng;
    }

    if (lng === 0) {
      lng = 0;
    }
  }

  return lng;
}
export function latitude(lat) {
  if (lat === undefined || lat === null) {
    throw new Error('lat is required');
  }

  if (lat > 90 || lat < -90) {
    lat = lat % 180;

    if (lat > 90) {
      lat = -180 + lat;
    }

    if (lat < -90) {
      lat = 180 + lat;
    }

    if (lat === 0) {
      lat = 0;
    }
  }

  return lat;
}
export function validateLngLat(lnglat, validate) {
  if (validate === false) {
    return lnglat;
  }

  var lng = longitude(lnglat[0]);
  var lat = latitude(lnglat[1]);

  if (lat > 85) {
    lat = 85;
  }

  if (lat < -85) {
    lat = -85;
  }

  return lnglat.length === 3 ? [lng, lat, lnglat[2]] : [lng, lat];
}
export function aProjectFlat(lnglat) {
  var maxs = 85.0511287798;
  var lat = Math.max(Math.min(maxs, lnglat[1]), -maxs);
  var scale = 256 << 20;
  var d = Math.PI / 180;
  var x = lnglat[0] * d;
  var y = lat * d;
  y = Math.log(Math.tan(Math.PI / 4 + y / 2));
  var a = 0.5 / Math.PI;
  var b = 0.5;
  var c = -0.5 / Math.PI;
  d = 0.5;
  x = scale * (a * x + b);
  y = scale * (c * y + d);
  return [Math.floor(x), Math.floor(y)];
}
export function unProjectFlat(px) {
  var a = 0.5 / Math.PI;
  var b = 0.5;
  var c = -0.5 / Math.PI;
  var d = 0.5;
  var scale = 256 << 20;

  var _px = _slicedToArray(px, 2),
      x = _px[0],
      y = _px[1];

  x = (x / scale - b) / a;
  y = (y / scale - d) / c;
  y = (Math.atan(Math.pow(Math.E, y)) - Math.PI / 4) * 2;
  d = Math.PI / 180;
  var lat = y / d;
  var lng = x / d;
  return [lng, lat];
}
export function lnglatDistance(coordinates1, coordinates2, units) {
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units = 'meters');
}
export function project(lnglat) {
  var d = Math.PI / 180;
  var max = 85.0511287798;
  var earthRadius = 6378137;
  var lat = Math.max(Math.min(max, lnglat[1]), -max);
  var sin = Math.sin(lat * d);
  var x = earthRadius * lnglat[0] * d;
  var y = earthRadius * Math.log((1 + sin) / (1 - sin)) / 2;
  return [x, y];
}
export function padBounds(b, bufferRatio) {
  var heightBuffer = Math.abs(b[1][1] - b[0][1]) * bufferRatio;
  var widthBuffer = Math.abs(b[1][0] - b[0][0]) * bufferRatio;
  return [[b[0][0] - widthBuffer, b[0][1] - heightBuffer], [b[1][0] + widthBuffer, b[1][1] + heightBuffer]];
}
export function boundsContains(b1, b2) {
  return b1[0][0] <= b2[0][0] && b1[0][1] <= b2[0][1] && b1[1][0] >= b2[1][0] && b1[1][1] >= b2[1][1];
}
export function bBoxToBounds(b1) {
  return [[b1[0], b1[1]], [b1[2], b1[3]]];
}
//# sourceMappingURL=geo.js.map