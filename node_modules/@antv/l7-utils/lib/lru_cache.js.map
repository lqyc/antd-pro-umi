{"version":3,"sources":["../src/lru_cache.ts"],"names":["LRUCache","limit","destroy","cache","order","defaultDestroy","clear","forEach","key","delete","value","deleteOrder","appendOrder","Object","keys","length","deleteCache","index","findIndex","o","splice","push"],"mappings":";;;;;;;;;;;;;IAUaA,Q;AAKX,sBAA4C;AAAA,QAAhCC,KAAgC,uEAAxB,EAAwB;AAAA,QAApBC,OAAoB;AAAA;AAAA,SAJpCD,KAIoC;AAAA,SAHpCE,KAGoC;AAAA,SAFpCD,OAEoC;AAAA,SADpCE,KACoC;AAC1C,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAO,IAAI,KAAKG,cAA/B;AACA,SAAKD,KAAL,GAAa,EAAb;AACA,SAAKE,KAAL;AACD;;;;WAED,iBAAe;AAAA;;AACb,WAAKF,KAAL,CAAWG,OAAX,CAAmB,UAACC,GAAD,EAAS;AAC1B,QAAA,KAAI,CAACC,MAAL,CAAYD,GAAZ;AACD,OAFD;AAGA,WAAKL,KAAL,GAAa,EAAb;AAEA,WAAKC,KAAL,GAAa,EAAb;AACD;;;WAED,aAAWI,GAAX,EAAwB;AACtB,UAAME,KAAK,GAAG,KAAKP,KAAL,CAAWK,GAAX,CAAd;;AACA,UAAIE,KAAJ,EAAW;AAET,aAAKC,WAAL,CAAiBH,GAAjB;AACA,aAAKI,WAAL,CAAiBJ,GAAjB;AACD;;AACD,aAAOE,KAAP;AACD;;;WAED,aAAWF,GAAX,EAAwBE,KAAxB,EAAoC;AAClC,UAAI,CAAC,KAAKP,KAAL,CAAWK,GAAX,CAAL,EAAsB;AAEpB,YAAIK,MAAM,CAACC,IAAP,CAAY,KAAKX,KAAjB,EAAwBY,MAAxB,KAAmC,KAAKd,KAA5C,EAAmD;AACjD,eAAKQ,MAAL,CAAY,KAAKL,KAAL,CAAW,CAAX,CAAZ;AACD;;AAED,aAAKD,KAAL,CAAWK,GAAX,IAAkBE,KAAlB;AACA,aAAKE,WAAL,CAAiBJ,GAAjB;AACD,OARD,MAQO;AAEL,aAAKC,MAAL,CAAYD,GAAZ;AAEA,aAAKL,KAAL,CAAWK,GAAX,IAAkBE,KAAlB;AACA,aAAKE,WAAL,CAAiBJ,GAAjB;AACD;AACF;;;WAED,iBAAcA,GAAd,EAA2B;AACzB,UAAME,KAAK,GAAG,KAAKP,KAAL,CAAWK,GAAX,CAAd;;AACA,UAAIE,KAAJ,EAAW;AACT,aAAKM,WAAL,CAAiBR,GAAjB;AACA,aAAKG,WAAL,CAAiBH,GAAjB;AACA,aAAKN,OAAL,CAAaQ,KAAb,EAAoBF,GAApB;AACD;AACF;;;WAED,qBAAoBA,GAApB,EAAiC;AAC/B,aAAO,KAAKL,KAAL,CAAWK,GAAX,CAAP;AACD;;;WAED,qBAAoBA,GAApB,EAAiC;AAC/B,UAAMS,KAAK,GAAG,KAAKb,KAAL,CAAWc,SAAX,CAAqB,UAACC,CAAD;AAAA,eAAOA,CAAC,KAAKX,GAAb;AAAA,OAArB,CAAd;;AACA,UAAIS,KAAK,IAAI,CAAb,EAAgB;AACd,aAAKb,KAAL,CAAWgB,MAAX,CAAkBH,KAAlB,EAAyB,CAAzB;AACD;AACF;;;WAED,qBAAoBT,GAApB,EAAiC;AAC/B,WAAKJ,KAAL,CAAWiB,IAAX,CAAgBb,GAAhB;AACD;;;WACD,wBAAuBE,KAAvB,EAAmCF,GAAnC,EAAgD;AAC9C,aAAO,IAAP;AACD","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\ntype callback = (...args: any[]) => void;\ninterface ICache {\n  [key: string]: any;\n}\nexport class LRUCache {\n  private limit: number;\n  private cache: ICache;\n  private destroy: (value: any, key: string) => void;\n  private order: any[];\n  constructor(limit = 50, destroy?: callback) {\n    this.limit = limit;\n    this.destroy = destroy || this.defaultDestroy;\n    this.order = [];\n    this.clear();\n  }\n\n  public clear() {\n    this.order.forEach((key) => {\n      this.delete(key);\n    });\n    this.cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this.order = [];\n  }\n\n  public get(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      // update order\n      this.deleteOrder(key);\n      this.appendOrder(key);\n    }\n    return value;\n  }\n\n  public set(key: string, value: any) {\n    if (!this.cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this.cache).length === this.limit) {\n        this.delete(this.order[0]);\n      }\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    }\n  }\n\n  public delete(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      this.deleteCache(key);\n      this.deleteOrder(key);\n      this.destroy(value, key);\n    }\n  }\n\n  private deleteCache(key: string) {\n    delete this.cache[key];\n  }\n\n  private deleteOrder(key: string) {\n    const index = this.order.findIndex((o) => o === key);\n    if (index >= 0) {\n      this.order.splice(index, 1);\n    }\n  }\n\n  private appendOrder(key: string) {\n    this.order.push(key);\n  }\n  private defaultDestroy(value: any, key: string) {\n    return null;\n  }\n}\n"],"file":"lru_cache.js"}