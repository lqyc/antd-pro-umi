{"version":3,"sources":["../../src/utils/project.ts"],"names":["DEGREES_TO_RADIANS","Math","PI","TILE_SIZE","EARTH_CIRCUMFERENCE","getDistanceScales","latitude","zoom","scale","highPrecision","flipY","undefined","pow","result","worldSize","latCosine","cos","pixelsPerDegreeX","pixelsPerDegreeY","altPixelsPerMeter","pixelsPerMeter","metersPerPixel","pixelsPerDegree","degreesPerPixel","latCosine2","tan","pixelsPerDegreeY2","altPixelsPerDegree2","altPixelsPerMeter2","pixelsPerDegree2","pixelsPerMeter2"],"mappings":"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","sourcesContent":["const DEGREES_TO_RADIANS = Math.PI / 180;\nconst TILE_SIZE = 512;\n// Average circumference (40075 km equatorial, 40007 km meridional)\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n\ninterface IDistanceScales {\n  pixelsPerMeter: [number, number, number];\n  metersPerPixel: [number, number, number];\n  pixelsPerDegree: [number, number, number];\n  degreesPerPixel: [number, number, number];\n  pixelsPerDegree2: [number, number, number];\n  pixelsPerMeter2: [number, number, number];\n}\n\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nexport function getDistanceScales({\n  latitude = 0,\n  zoom = 0,\n  scale,\n  highPrecision = false,\n  flipY = false,\n}: Partial<{\n  latitude: number;\n  zoom: number;\n  scale: number | undefined;\n  highPrecision: boolean;\n  flipY: boolean;\n}>): IDistanceScales {\n  // Calculate scale from zoom if not provided\n  scale = scale !== undefined ? scale : Math.pow(2, zoom);\n\n  // @ts-ignore\n  const result: IDistanceScales = {};\n  const worldSize = TILE_SIZE * scale;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n\n  /**\n   * Number of pixels occupied by one degree longitude around current lat/lon:\n   *  pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)\n   *     = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)\n   *   pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)\n   *     = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)\n   */\n  const pixelsPerDegreeX = worldSize / 360;\n  const pixelsPerDegreeY = pixelsPerDegreeX / latCosine;\n\n  /**\n   * Number of pixels occupied by one meter around current lat/lon:\n   */\n  const altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n\n  /**\n   * LngLat: longitude -> east and latitude -> north (bottom left)\n   * UTM meter offset: x -> east and y -> north (bottom left)\n   * World space: x -> east and y -> south (top left)\n   *\n   * Y needs to be flipped when converting delta degree/meter to delta pixels\n   */\n  result.pixelsPerMeter = [\n    altPixelsPerMeter,\n    -altPixelsPerMeter,\n    altPixelsPerMeter,\n  ];\n  result.metersPerPixel = [\n    1 / altPixelsPerMeter,\n    -1 / altPixelsPerMeter,\n    1 / altPixelsPerMeter,\n  ];\n\n  result.pixelsPerDegree = [\n    pixelsPerDegreeX,\n    -pixelsPerDegreeY,\n    altPixelsPerMeter,\n  ];\n  result.degreesPerPixel = [\n    1 / pixelsPerDegreeX,\n    -1 / pixelsPerDegreeY,\n    1 / altPixelsPerMeter,\n  ];\n\n  /**\n   * Taylor series 2nd order for 1/latCosine\n   *  f'(a) * (x - a)\n   *     = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat\n   *     = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat\n   */\n  if (highPrecision) {\n    const latCosine2 =\n      (DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS)) /\n      latCosine;\n    const pixelsPerDegreeY2 = (pixelsPerDegreeX * latCosine2) / 2;\n\n    const altPixelsPerDegree2 = (worldSize / EARTH_CIRCUMFERENCE) * latCosine2;\n    const altPixelsPerMeter2 =\n      (altPixelsPerDegree2 / pixelsPerDegreeY) * altPixelsPerMeter;\n\n    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];\n    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];\n\n    if (flipY) {\n      result.pixelsPerDegree2[1] = -result.pixelsPerDegree2[1];\n      result.pixelsPerMeter2[1] = -result.pixelsPerMeter2[1];\n    }\n  }\n\n  if (flipY) {\n    result.pixelsPerMeter[1] = -result.pixelsPerMeter[1];\n    result.metersPerPixel[1] = -result.metersPerPixel[1];\n    result.pixelsPerDegree[1] = -result.pixelsPerDegree[1];\n    result.degreesPerPixel[1] = -result.degreesPerPixel[1];\n  }\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return result;\n}\n"],"file":"project.js"}