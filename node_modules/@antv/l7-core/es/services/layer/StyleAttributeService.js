import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

var _bytesPerElementMap, _dec, _dec2, _class, _class2, _descriptor, _temp;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { inject, injectable } from 'inversify';
import { TYPES } from '../../types';
import { gl } from '../renderer/gl';
import StyleAttribute from './StyleAttribute';

function sleep(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

var bytesPerElementMap = (_bytesPerElementMap = {}, _defineProperty(_bytesPerElementMap, gl.FLOAT, 4), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_BYTE, 1), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_SHORT, 2), _bytesPerElementMap);
var StyleAttributeService = (_dec = injectable(), _dec2 = inject(TYPES.IRendererService), _dec(_class = (_class2 = (_temp = function () {
  function StyleAttributeService() {
    _classCallCheck(this, StyleAttributeService);

    this.attributesAndIndices = void 0;

    _initializerDefineProperty(this, "rendererService", _descriptor, this);

    this.attributes = [];
    this.triangulation = void 0;
    this.featureLayout = {
      sizePerElement: 0,
      elements: []
    };
  }

  _createClass(StyleAttributeService, [{
    key: "registerStyleAttribute",
    value: function registerStyleAttribute(options) {
      var attributeToUpdate = this.getLayerStyleAttribute(options.name || '');

      if (attributeToUpdate) {
        attributeToUpdate.setProps(options);
      } else {
        attributeToUpdate = new StyleAttribute(options);
        this.attributes.push(attributeToUpdate);
      }

      return attributeToUpdate;
    }
  }, {
    key: "updateStyleAttribute",
    value: function updateStyleAttribute(attributeName, options, updateOptions) {
      var attributeToUpdate = this.getLayerStyleAttribute(attributeName);

      if (!attributeToUpdate) {
        attributeToUpdate = this.registerStyleAttribute(_objectSpread(_objectSpread({}, options), {}, {
          name: attributeName
        }));
      }

      var scale = options.scale;

      if (scale && attributeToUpdate) {
        attributeToUpdate.scale = scale;
        attributeToUpdate.needRescale = true;
        attributeToUpdate.needRemapping = true;
        attributeToUpdate.needRegenerateVertices = true;

        if (updateOptions && updateOptions.featureRange) {
          attributeToUpdate.featureRange = updateOptions.featureRange;
        }
      }
    }
  }, {
    key: "getLayerStyleAttributes",
    value: function getLayerStyleAttributes() {
      return this.attributes;
    }
  }, {
    key: "getLayerStyleAttribute",
    value: function getLayerStyleAttribute(attributeName) {
      return this.attributes.find(function (attribute) {
        return attribute.name === attributeName;
      });
    }
  }, {
    key: "getLayerAttributeScale",
    value: function getLayerAttributeScale(name) {
      var _attribute$scale;

      var attribute = this.getLayerStyleAttribute(name);
      var scale = attribute === null || attribute === void 0 ? void 0 : (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers;

      if (scale && scale[0]) {
        return scale[0].func;
      }

      return null;
    }
  }, {
    key: "updateAttributeByFeatureRange",
    value: function updateAttributeByFeatureRange(attributeName, features) {
      var startFeatureIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var endFeatureIdx = arguments.length > 3 ? arguments[3] : undefined;
      var attributeToUpdate = this.attributes.find(function (attribute) {
        return attribute.name === attributeName;
      });

      if (attributeToUpdate && attributeToUpdate.descriptor) {
        var descriptor = attributeToUpdate.descriptor;
        var update = descriptor.update,
            buffer = descriptor.buffer,
            _descriptor$size = descriptor.size,
            size = _descriptor$size === void 0 ? 0 : _descriptor$size;
        var bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];

        if (update) {
          var _this$featureLayout = this.featureLayout,
              elements = _this$featureLayout.elements,
              sizePerElement = _this$featureLayout.sizePerElement;
          var featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);

          if (!featuresToUpdate.length) {
            return;
          }

          var offset = featuresToUpdate[0].offset;
          var bufferOffsetInBytes = offset * size * bytesPerElement;
          var updatedBufferData = featuresToUpdate.map(function (_ref, attributeIdx) {
            var featureIdx = _ref.featureIdx,
                vertices = _ref.vertices,
                normals = _ref.normals;
            var verticesNumForCurrentFeature = vertices.length / sizePerElement;
            var featureData = [];

            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
              var normal = normals ? normals.slice(vertexIdx * 3, vertexIdx * 3 + 3) : [];
              featureData.push.apply(featureData, _toConsumableArray(update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal)));
            }

            return featureData;
          }).reduce(function (prev, cur) {
            prev.push.apply(prev, _toConsumableArray(cur));
            return prev;
          }, []);
          attributeToUpdate.vertexAttribute.updateBuffer({
            data: updatedBufferData,
            offset: bufferOffsetInBytes
          });
        }
      }
    }
  }, {
    key: "createAttributesAndIndices",
    value: function createAttributesAndIndices(features, triangulation) {
      var _this = this;

      this.featureLayout = {
        sizePerElement: 0,
        elements: []
      };

      if (triangulation) {
        this.triangulation = triangulation;
      }

      var descriptors = this.attributes.map(function (attr) {
        attr.resetDescriptor();
        return attr.descriptor;
      });
      var verticesNum = 0;
      var vertices = [];
      var indices = [];
      var normals = [];
      var size = 3;
      features.forEach(function (feature, featureIdx) {
        var _this$triangulation = _this.triangulation(feature),
            indicesForCurrentFeature = _this$triangulation.indices,
            verticesForCurrentFeature = _this$triangulation.vertices,
            normalsForCurrentFeature = _this$triangulation.normals,
            vertexSize = _this$triangulation.size;

        indicesForCurrentFeature.forEach(function (i) {
          indices.push(i + verticesNum);
        });
        size = vertexSize;
        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;
        _this.featureLayout.sizePerElement = size;

        _this.featureLayout.elements.push({
          featureIdx: featureIdx,
          vertices: verticesForCurrentFeature,
          normals: normalsForCurrentFeature,
          offset: verticesNum
        });

        verticesNum += verticesNumForCurrentFeature;

        var _loop = function _loop(vertexIdx) {
          var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
          var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
          descriptors.forEach(function (descriptor, attributeIdx) {
            if (descriptor && descriptor.update) {
              var _ref2;

              (_ref2 = descriptor.buffer.data).push.apply(_ref2, _toConsumableArray(descriptor.update(feature, featureIdx, vertice, vertexIdx, normal)));
            }
          });
        };

        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
          _loop(vertexIdx);
        }
      });
      var _this$rendererService = this.rendererService,
          createAttribute = _this$rendererService.createAttribute,
          createBuffer = _this$rendererService.createBuffer,
          createElements = _this$rendererService.createElements;
      var attributes = {};
      descriptors.forEach(function (descriptor, attributeIdx) {
        if (descriptor) {
          var buffer = descriptor.buffer,
              update = descriptor.update,
              name = descriptor.name,
              rest = _objectWithoutProperties(descriptor, ["buffer", "update", "name"]);

          var vertexAttribute = createAttribute(_objectSpread({
            buffer: createBuffer(buffer)
          }, rest));
          attributes[descriptor.name || ''] = vertexAttribute;
          _this.attributes[attributeIdx].vertexAttribute = vertexAttribute;
        }
      });
      var elements = createElements({
        data: indices,
        type: gl.UNSIGNED_INT,
        count: indices.length
      });
      this.attributesAndIndices = {
        attributes: attributes,
        elements: elements
      };
      return this.attributesAndIndices;
    }
  }, {
    key: "clearAllAttributes",
    value: function clearAllAttributes() {
      var _this$attributesAndIn;

      this.attributes.forEach(function (attribute) {
        if (attribute.vertexAttribute) {
          attribute.vertexAttribute.destroy();
        }
      });
      (_this$attributesAndIn = this.attributesAndIndices) === null || _this$attributesAndIn === void 0 ? void 0 : _this$attributesAndIn.elements.destroy();
      this.attributes = [];
    }
  }]);

  return StyleAttributeService;
}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "rendererService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
export { StyleAttributeService as default };
//# sourceMappingURL=StyleAttributeService.js.map