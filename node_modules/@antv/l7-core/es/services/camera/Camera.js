import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';
import { createVec3, getAngle } from '../../utils/math';
export var CAMERA_TYPE;

(function (CAMERA_TYPE) {
  CAMERA_TYPE["ORBITING"] = "ORBITING";
  CAMERA_TYPE["EXPLORING"] = "EXPLORING";
  CAMERA_TYPE["TRACKING"] = "TRACKING";
})(CAMERA_TYPE || (CAMERA_TYPE = {}));

export var CAMERA_TRACKING_MODE;

(function (CAMERA_TRACKING_MODE) {
  CAMERA_TRACKING_MODE["DEFAULT"] = "DEFAULT";
  CAMERA_TRACKING_MODE["ROTATIONAL"] = "ROTATIONAL";
  CAMERA_TRACKING_MODE["TRANSLATIONAL"] = "TRANSLATIONAL";
  CAMERA_TRACKING_MODE["CINEMATIC"] = "CINEMATIC";
})(CAMERA_TRACKING_MODE || (CAMERA_TRACKING_MODE = {}));

var DEG_2_RAD = Math.PI / 180;
var RAD_2_DEG = 180 / Math.PI;

var Camera = function () {
  function Camera(type) {
    _classCallCheck(this, Camera);

    this.matrix = mat4.create();
    this.right = vec3.fromValues(1, 0, 0);
    this.up = vec3.fromValues(0, 1, 0);
    this.forward = vec3.fromValues(0, 0, 1);
    this.position = vec3.fromValues(0, 0, 1);
    this.focalPoint = vec3.fromValues(0, 0, 0);
    this.distanceVector = vec3.fromValues(0, 0, 0);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 10000;
    this.aspect = 1;
    this.perspective = mat4.create();
    this.following = undefined;
    this.type = CAMERA_TYPE.EXPLORING;
    this.trackingMode = CAMERA_TRACKING_MODE.DEFAULT;
    this.setType(type, undefined);
  }

  _createClass(Camera, [{
    key: "setType",
    value: function setType(type, trackingMode) {
      this.type = type;

      if (this.type === CAMERA_TYPE.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }

      this._getAngles();

      if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {
        this.setTrackingMode(trackingMode);
      }
    }
  }, {
    key: "setTrackingMode",
    value: function setTrackingMode(trackingMode) {
      if (this.type !== CAMERA_TYPE.TRACKING) {
        throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');
      }

      this.trackingMode = trackingMode;
    }
  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(flag) {
      this.rotateWorld = flag;

      this._getAngles();
    }
  }, {
    key: "getViewTransform",
    value: function getViewTransform() {
      return mat4.invert(mat4.create(), this.matrix);
    }
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix) {
      this.matrix = matrix;

      this._update();
    }
  }, {
    key: "setPerspective",
    value: function setPerspective(near, far, angle, aspect) {
      this.fov = angle;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      this.updatePerspective();
    }
  }, {
    key: "updatePerspective",
    value: function updatePerspective() {
      mat4.perspective(this.perspective, this.fov * DEG_2_RAD, this.aspect, this.near, this.far);
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y, z) {
      this._setPosition(x, y, z);

      this.setFocalPoint(this.focalPoint);
      return this;
    }
  }, {
    key: "setFocalPoint",
    value: function setFocalPoint(x, y, z) {
      var up = vec3.fromValues(0, 1, 0);
      this.focalPoint = createVec3(x, y, z);

      if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {
        var d = vec3.subtract(vec3.create(), this.focalPoint, this.position);
        x = d[0];
        y = d[1];
        z = d[2];
        var r = vec3.length(d);
        var el = Math.asin(y / r) * RAD_2_DEG;
        var az = 90 + Math.atan2(z, x) * RAD_2_DEG;
        var m = mat4.create();
        mat4.rotateY(m, m, az * DEG_2_RAD);
        mat4.rotateX(m, m, el * DEG_2_RAD);
        up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);
      }

      mat4.invert(this.matrix, mat4.lookAt(mat4.create(), this.position, this.focalPoint, up));

      this._getAxes();

      this._getDistance();

      this._getAngles();

      return this;
    }
  }, {
    key: "setDistance",
    value: function setDistance(d) {
      if (this.distance === d || d < 0) {
        return;
      }

      this.distance = d;
      this.dollyingStep = this.distance / 100;
      var pos = vec3.create();
      var n = this.forward;
      var f = this.focalPoint;
      pos[0] = d * n[0] + f[0];
      pos[1] = d * n[1] + f[1];
      pos[2] = d * n[2] + f[2];

      this._setPosition(pos);

      return this;
    }
  }, {
    key: "changeAzimuth",
    value: function changeAzimuth(az) {
      this.setAzimuth(this.azimuth + az);
      return this;
    }
  }, {
    key: "changeElevation",
    value: function changeElevation(el) {
      this.setElevation(this.elevation + el);
      return this;
    }
  }, {
    key: "changeRoll",
    value: function changeRoll(rl) {
      this.setRoll(this.roll + rl);
      return this;
    }
  }, {
    key: "setAzimuth",
    value: function setAzimuth(az) {
      this.azimuth = getAngle(az);
      this.computeMatrix();

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      return this;
    }
  }, {
    key: "getAzimuth",
    value: function getAzimuth() {
      return this.azimuth;
    }
  }, {
    key: "setElevation",
    value: function setElevation(el) {
      this.elevation = getAngle(el);
      this.computeMatrix();

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      return this;
    }
  }, {
    key: "setRoll",
    value: function setRoll(angle) {
      this.roll = getAngle(angle);
      this.computeMatrix();

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(azimuth, elevation, roll) {
      if (this.type === CAMERA_TYPE.EXPLORING) {
        azimuth = getAngle(azimuth);
        elevation = getAngle(elevation);
        roll = getAngle(roll);
        var rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD);
        var rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD);
        var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], roll * DEG_2_RAD);
        var rotQ = quat.multiply(quat.create(), rotY, rotX);
        rotQ = quat.multiply(quat.create(), rotQ, rotZ);
        var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);
        mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
        mat4.multiply(this.matrix, this.matrix, rotMatrix);
        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else {
        if (Math.abs(this.elevation + elevation) > 90) {
          return;
        }

        this.relElevation = getAngle(elevation);
        this.relAzimuth = getAngle(azimuth);
        this.relRoll = getAngle(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        this.computeMatrix();
      }

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      this._update();

      return this;
    }
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      var coords = createVec3(tx, ty, 0);
      var pos = vec3.clone(this.position);
      vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));
      vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));

      this._setPosition(pos);

      return this;
    }
  }, {
    key: "dolly",
    value: function dolly(value) {
      var n = this.forward;
      var pos = vec3.clone(this.position);
      var step = value * this.dollyingStep;
      pos[0] += step * n[0];
      pos[1] += step * n[1];
      pos[2] += step * n[2];

      this._setPosition(pos);

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getDistance();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        vec3.add(this.focalPoint, pos, this.distanceVector);
      }

      return this;
    }
  }, {
    key: "_update",
    value: function _update() {
      this._getAxes();

      this._getPosition();

      this._getDistance();

      this._getAngles();
    }
  }, {
    key: "computeMatrix",
    value: function computeMatrix() {
      var rotX;
      var rotY;
      var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], this.roll * DEG_2_RAD);
      mat4.identity(this.matrix);
      rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);
      rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * this.azimuth * DEG_2_RAD);
      var rotQ = quat.multiply(quat.create(), rotY, rotX);
      rotQ = quat.multiply(quat.create(), rotQ, rotZ);
      var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        mat4.translate(this.matrix, this.matrix, this.focalPoint);
        mat4.multiply(this.matrix, this.matrix, rotMatrix);
        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        mat4.translate(this.matrix, this.matrix, this.position);
        mat4.multiply(this.matrix, this.matrix, rotMatrix);
      }
    }
  }, {
    key: "_setPosition",
    value: function _setPosition(x, y, z) {
      this.position = createVec3(x, y, z);
      var m = this.matrix;
      m[12] = this.position[0];
      m[13] = this.position[1];
      m[14] = this.position[2];
      m[15] = 1;
    }
  }, {
    key: "_getAxes",
    value: function _getAxes() {
      vec3.copy(this.right, createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)));
      vec3.copy(this.up, createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)));
      vec3.copy(this.forward, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)));
      vec3.normalize(this.right, this.right);
      vec3.normalize(this.up, this.up);
      vec3.normalize(this.forward, this.forward);
    }
  }, {
    key: "_getAngles",
    value: function _getAngles() {
      var x = this.distanceVector[0];
      var y = this.distanceVector[1];
      var z = this.distanceVector[2];
      var r = vec3.length(this.distanceVector);

      if (r === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }

      if (this.type === CAMERA_TYPE.TRACKING) {
        this.elevation = Math.asin(y / r) * RAD_2_DEG;
        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
      } else {
        if (this.rotateWorld) {
          this.elevation = Math.asin(y / r) * RAD_2_DEG;
          this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
        } else {
          this.elevation = -Math.asin(y / r) * RAD_2_DEG;
          this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;
        }
      }
    }
  }, {
    key: "_getPosition",
    value: function _getPosition() {
      vec3.copy(this.position, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix)));

      this._getDistance();
    }
  }, {
    key: "_getFocalPoint",
    value: function _getFocalPoint() {
      vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3.fromMat4(mat3.create(), this.matrix));
      vec3.add(this.focalPoint, this.position, this.distanceVector);

      this._getDistance();
    }
  }, {
    key: "_getDistance",
    value: function _getDistance() {
      this.distanceVector = vec3.subtract(vec3.create(), this.focalPoint, this.position);
      this.distance = vec3.length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    }
  }]);

  return Camera;
}();

export { Camera as default };
//# sourceMappingURL=Camera.js.map