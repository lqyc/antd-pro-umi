"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CAMERA_TRACKING_MODE = exports.CAMERA_TYPE = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _glMatrix = require("gl-matrix");

var _math = require("../../utils/math");

var CAMERA_TYPE;
exports.CAMERA_TYPE = CAMERA_TYPE;

(function (CAMERA_TYPE) {
  CAMERA_TYPE["ORBITING"] = "ORBITING";
  CAMERA_TYPE["EXPLORING"] = "EXPLORING";
  CAMERA_TYPE["TRACKING"] = "TRACKING";
})(CAMERA_TYPE || (exports.CAMERA_TYPE = CAMERA_TYPE = {}));

var CAMERA_TRACKING_MODE;
exports.CAMERA_TRACKING_MODE = CAMERA_TRACKING_MODE;

(function (CAMERA_TRACKING_MODE) {
  CAMERA_TRACKING_MODE["DEFAULT"] = "DEFAULT";
  CAMERA_TRACKING_MODE["ROTATIONAL"] = "ROTATIONAL";
  CAMERA_TRACKING_MODE["TRANSLATIONAL"] = "TRANSLATIONAL";
  CAMERA_TRACKING_MODE["CINEMATIC"] = "CINEMATIC";
})(CAMERA_TRACKING_MODE || (exports.CAMERA_TRACKING_MODE = CAMERA_TRACKING_MODE = {}));

var DEG_2_RAD = Math.PI / 180;
var RAD_2_DEG = 180 / Math.PI;

var Camera = function () {
  function Camera(type) {
    (0, _classCallCheck2.default)(this, Camera);
    this.matrix = _glMatrix.mat4.create();
    this.right = _glMatrix.vec3.fromValues(1, 0, 0);
    this.up = _glMatrix.vec3.fromValues(0, 1, 0);
    this.forward = _glMatrix.vec3.fromValues(0, 0, 1);
    this.position = _glMatrix.vec3.fromValues(0, 0, 1);
    this.focalPoint = _glMatrix.vec3.fromValues(0, 0, 0);
    this.distanceVector = _glMatrix.vec3.fromValues(0, 0, 0);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 10000;
    this.aspect = 1;
    this.perspective = _glMatrix.mat4.create();
    this.following = undefined;
    this.type = CAMERA_TYPE.EXPLORING;
    this.trackingMode = CAMERA_TRACKING_MODE.DEFAULT;
    this.setType(type, undefined);
  }

  (0, _createClass2.default)(Camera, [{
    key: "setType",
    value: function setType(type, trackingMode) {
      this.type = type;

      if (this.type === CAMERA_TYPE.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }

      this._getAngles();

      if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {
        this.setTrackingMode(trackingMode);
      }
    }
  }, {
    key: "setTrackingMode",
    value: function setTrackingMode(trackingMode) {
      if (this.type !== CAMERA_TYPE.TRACKING) {
        throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');
      }

      this.trackingMode = trackingMode;
    }
  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(flag) {
      this.rotateWorld = flag;

      this._getAngles();
    }
  }, {
    key: "getViewTransform",
    value: function getViewTransform() {
      return _glMatrix.mat4.invert(_glMatrix.mat4.create(), this.matrix);
    }
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix) {
      this.matrix = matrix;

      this._update();
    }
  }, {
    key: "setPerspective",
    value: function setPerspective(near, far, angle, aspect) {
      this.fov = angle;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      this.updatePerspective();
    }
  }, {
    key: "updatePerspective",
    value: function updatePerspective() {
      _glMatrix.mat4.perspective(this.perspective, this.fov * DEG_2_RAD, this.aspect, this.near, this.far);
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y, z) {
      this._setPosition(x, y, z);

      this.setFocalPoint(this.focalPoint);
      return this;
    }
  }, {
    key: "setFocalPoint",
    value: function setFocalPoint(x, y, z) {
      var up = _glMatrix.vec3.fromValues(0, 1, 0);

      this.focalPoint = (0, _math.createVec3)(x, y, z);

      if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {
        var d = _glMatrix.vec3.subtract(_glMatrix.vec3.create(), this.focalPoint, this.position);

        x = d[0];
        y = d[1];
        z = d[2];

        var r = _glMatrix.vec3.length(d);

        var el = Math.asin(y / r) * RAD_2_DEG;
        var az = 90 + Math.atan2(z, x) * RAD_2_DEG;

        var m = _glMatrix.mat4.create();

        _glMatrix.mat4.rotateY(m, m, az * DEG_2_RAD);

        _glMatrix.mat4.rotateX(m, m, el * DEG_2_RAD);

        up = _glMatrix.vec3.transformMat4(_glMatrix.vec3.create(), [0, 1, 0], m);
      }

      _glMatrix.mat4.invert(this.matrix, _glMatrix.mat4.lookAt(_glMatrix.mat4.create(), this.position, this.focalPoint, up));

      this._getAxes();

      this._getDistance();

      this._getAngles();

      return this;
    }
  }, {
    key: "setDistance",
    value: function setDistance(d) {
      if (this.distance === d || d < 0) {
        return;
      }

      this.distance = d;
      this.dollyingStep = this.distance / 100;

      var pos = _glMatrix.vec3.create();

      var n = this.forward;
      var f = this.focalPoint;
      pos[0] = d * n[0] + f[0];
      pos[1] = d * n[1] + f[1];
      pos[2] = d * n[2] + f[2];

      this._setPosition(pos);

      return this;
    }
  }, {
    key: "changeAzimuth",
    value: function changeAzimuth(az) {
      this.setAzimuth(this.azimuth + az);
      return this;
    }
  }, {
    key: "changeElevation",
    value: function changeElevation(el) {
      this.setElevation(this.elevation + el);
      return this;
    }
  }, {
    key: "changeRoll",
    value: function changeRoll(rl) {
      this.setRoll(this.roll + rl);
      return this;
    }
  }, {
    key: "setAzimuth",
    value: function setAzimuth(az) {
      this.azimuth = (0, _math.getAngle)(az);
      this.computeMatrix();

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      return this;
    }
  }, {
    key: "getAzimuth",
    value: function getAzimuth() {
      return this.azimuth;
    }
  }, {
    key: "setElevation",
    value: function setElevation(el) {
      this.elevation = (0, _math.getAngle)(el);
      this.computeMatrix();

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      return this;
    }
  }, {
    key: "setRoll",
    value: function setRoll(angle) {
      this.roll = (0, _math.getAngle)(angle);
      this.computeMatrix();

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(azimuth, elevation, roll) {
      if (this.type === CAMERA_TYPE.EXPLORING) {
        azimuth = (0, _math.getAngle)(azimuth);
        elevation = (0, _math.getAngle)(elevation);
        roll = (0, _math.getAngle)(roll);

        var rotX = _glMatrix.quat.setAxisAngle(_glMatrix.quat.create(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD);

        var rotY = _glMatrix.quat.setAxisAngle(_glMatrix.quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD);

        var rotZ = _glMatrix.quat.setAxisAngle(_glMatrix.quat.create(), [0, 0, 1], roll * DEG_2_RAD);

        var rotQ = _glMatrix.quat.multiply(_glMatrix.quat.create(), rotY, rotX);

        rotQ = _glMatrix.quat.multiply(_glMatrix.quat.create(), rotQ, rotZ);

        var rotMatrix = _glMatrix.mat4.fromQuat(_glMatrix.mat4.create(), rotQ);

        _glMatrix.mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);

        _glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);

        _glMatrix.mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else {
        if (Math.abs(this.elevation + elevation) > 90) {
          return;
        }

        this.relElevation = (0, _math.getAngle)(elevation);
        this.relAzimuth = (0, _math.getAngle)(azimuth);
        this.relRoll = (0, _math.getAngle)(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        this.computeMatrix();
      }

      this._getAxes();

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }

      this._update();

      return this;
    }
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      var coords = (0, _math.createVec3)(tx, ty, 0);

      var pos = _glMatrix.vec3.clone(this.position);

      _glMatrix.vec3.add(pos, pos, _glMatrix.vec3.scale(_glMatrix.vec3.create(), this.right, coords[0]));

      _glMatrix.vec3.add(pos, pos, _glMatrix.vec3.scale(_glMatrix.vec3.create(), this.up, coords[1]));

      this._setPosition(pos);

      return this;
    }
  }, {
    key: "dolly",
    value: function dolly(value) {
      var n = this.forward;

      var pos = _glMatrix.vec3.clone(this.position);

      var step = value * this.dollyingStep;
      pos[0] += step * n[0];
      pos[1] += step * n[1];
      pos[2] += step * n[2];

      this._setPosition(pos);

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getDistance();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        _glMatrix.vec3.add(this.focalPoint, pos, this.distanceVector);
      }

      return this;
    }
  }, {
    key: "_update",
    value: function _update() {
      this._getAxes();

      this._getPosition();

      this._getDistance();

      this._getAngles();
    }
  }, {
    key: "computeMatrix",
    value: function computeMatrix() {
      var rotX;
      var rotY;

      var rotZ = _glMatrix.quat.setAxisAngle(_glMatrix.quat.create(), [0, 0, 1], this.roll * DEG_2_RAD);

      _glMatrix.mat4.identity(this.matrix);

      rotX = _glMatrix.quat.setAxisAngle(_glMatrix.quat.create(), [1, 0, 0], (this.rotateWorld || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);
      rotY = _glMatrix.quat.setAxisAngle(_glMatrix.quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * this.azimuth * DEG_2_RAD);

      var rotQ = _glMatrix.quat.multiply(_glMatrix.quat.create(), rotY, rotX);

      rotQ = _glMatrix.quat.multiply(_glMatrix.quat.create(), rotQ, rotZ);

      var rotMatrix = _glMatrix.mat4.fromQuat(_glMatrix.mat4.create(), rotQ);

      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        _glMatrix.mat4.translate(this.matrix, this.matrix, this.focalPoint);

        _glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);

        _glMatrix.mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        _glMatrix.mat4.translate(this.matrix, this.matrix, this.position);

        _glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);
      }
    }
  }, {
    key: "_setPosition",
    value: function _setPosition(x, y, z) {
      this.position = (0, _math.createVec3)(x, y, z);
      var m = this.matrix;
      m[12] = this.position[0];
      m[13] = this.position[1];
      m[14] = this.position[2];
      m[15] = 1;
    }
  }, {
    key: "_getAxes",
    value: function _getAxes() {
      _glMatrix.vec3.copy(this.right, (0, _math.createVec3)(_glMatrix.vec4.transformMat4(_glMatrix.vec4.create(), [1, 0, 0, 0], this.matrix)));

      _glMatrix.vec3.copy(this.up, (0, _math.createVec3)(_glMatrix.vec4.transformMat4(_glMatrix.vec4.create(), [0, 1, 0, 0], this.matrix)));

      _glMatrix.vec3.copy(this.forward, (0, _math.createVec3)(_glMatrix.vec4.transformMat4(_glMatrix.vec4.create(), [0, 0, 1, 0], this.matrix)));

      _glMatrix.vec3.normalize(this.right, this.right);

      _glMatrix.vec3.normalize(this.up, this.up);

      _glMatrix.vec3.normalize(this.forward, this.forward);
    }
  }, {
    key: "_getAngles",
    value: function _getAngles() {
      var x = this.distanceVector[0];
      var y = this.distanceVector[1];
      var z = this.distanceVector[2];

      var r = _glMatrix.vec3.length(this.distanceVector);

      if (r === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }

      if (this.type === CAMERA_TYPE.TRACKING) {
        this.elevation = Math.asin(y / r) * RAD_2_DEG;
        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
      } else {
        if (this.rotateWorld) {
          this.elevation = Math.asin(y / r) * RAD_2_DEG;
          this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
        } else {
          this.elevation = -Math.asin(y / r) * RAD_2_DEG;
          this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;
        }
      }
    }
  }, {
    key: "_getPosition",
    value: function _getPosition() {
      _glMatrix.vec3.copy(this.position, (0, _math.createVec3)(_glMatrix.vec4.transformMat4(_glMatrix.vec4.create(), [0, 0, 0, 1], this.matrix)));

      this._getDistance();
    }
  }, {
    key: "_getFocalPoint",
    value: function _getFocalPoint() {
      _glMatrix.vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], _glMatrix.mat3.fromMat4(_glMatrix.mat3.create(), this.matrix));

      _glMatrix.vec3.add(this.focalPoint, this.position, this.distanceVector);

      this._getDistance();
    }
  }, {
    key: "_getDistance",
    value: function _getDistance() {
      this.distanceVector = _glMatrix.vec3.subtract(_glMatrix.vec3.create(), this.focalPoint, this.position);
      this.distance = _glMatrix.vec3.length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    }
  }]);
  return Camera;
}();

exports.default = Camera;
//# sourceMappingURL=Camera.js.map