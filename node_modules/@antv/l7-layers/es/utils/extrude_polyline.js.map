{"version":3,"sources":["../../src/utils/extrude_polyline.ts"],"names":["aProjectFlat","vec2","tmp","create","capEnd","lineA","lineB","tangent","computeMiter","lineTangent","miter","start","end","halfThick","add","normalize","fromValues","tmpvec","dot","computeNormal","out","dir","set","direction","a","b","sub","isPointEqual","getArrayUnique","matrix","map","Map","i","length","key","toString","get","splice","ExtrudePolyline","opts","complex","join","cap","miterLimit","thickness","normal","lastFlip","started","dash","totalDistance","positions","indices","normals","startIndex","points","total","count","last","cur","next","amt","segment","index","capSquare","joinBevel","flatCur","flatLast","segmentDistance","lineSegmentDistance","out1","out2","push","extrusions","flatNext","subtract","miterLen","flip","bevel","limit","copy","point","distanceRadio","b1","a1","dx","dy","Math","sqrt"],"mappings":"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","sourcesContent":["import { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nconst tmp = vec2.create();\nconst capEnd = vec2.create();\nconst lineA = vec2.create();\nconst lineB = vec2.create();\nconst tangent = vec2.create();\n\nexport function computeMiter(\n  lineTangent: vec2,\n  miter: vec2,\n  start: vec2,\n  end: vec2,\n  halfThick: number,\n): [number, vec2] {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  const tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out: vec2, dir: vec2) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\n\nexport function direction(out: vec2, a: vec2, b: vec2) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\n\nfunction isPointEqual(a: vec2, b: vec2) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nfunction getArrayUnique(matrix: number[][]) {\n  const map = new Map();\n  for (let i = 0; i < matrix.length; i++) {\n    const key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\n\nexport interface IExtrudeLineOption {\n  join: string;\n  cap: string;\n  dash: boolean;\n  closed: boolean;\n  indexOffset: number;\n  miterLimit: number;\n  thickness: number;\n}\nexport default class ExtrudePolyline {\n  public complex: {\n    positions: number[];\n    indices: number[];\n    normals: number[];\n    startIndex: number;\n  };\n  private join: string;\n  private cap: string;\n  private miterLimit: number;\n  private thickness: number;\n  private normal: vec2 | null;\n  private lastFlip: number = -1;\n  private miter: vec2 = vec2.fromValues(0, 0);\n  private started: boolean = false;\n  private dash: boolean = false;\n  private totalDistance: number = 0;\n\n  constructor(opts: Partial<IExtrudeLineOption> = {}) {\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n    };\n  }\n  public extrude(points: number[][]) {\n    const complex = this.complex;\n    if (points.length <= 1) {\n      return complex;\n    }\n    this.lastFlip = -1;\n    this.started = false;\n    this.normal = null;\n    this.totalDistance = 0;\n    // 去除数组里重复的点\n    // points = getArrayUnique(points);\n    const total = points.length;\n    let count = complex.startIndex;\n    for (let i = 1; i < total; i++) {\n      const last = points[i - 1] as vec2;\n      const cur = points[i] as vec2;\n      const next = i < points.length - 1 ? points[i + 1] : null;\n      const amt = this.segment(complex, count, last, cur, next as vec2);\n      count += amt;\n    }\n    if (this.dash) {\n      for (let i = 0; i < complex.positions.length / 6; i++) {\n        complex.positions[i * 6 + 5] = this.totalDistance;\n      }\n    }\n    complex.startIndex = complex.positions.length / 6;\n    return complex;\n  }\n  private segment(\n    complex: any,\n    index: number,\n    last: vec2,\n    cur: vec2,\n    next: vec2,\n  ) {\n    let count = 0;\n    const indices = complex.indices;\n    const positions = complex.positions;\n    const normals = complex.normals;\n    const capSquare = this.cap === 'square';\n    const joinBevel = this.join === 'bevel';\n    const flatCur = aProjectFlat([cur[0], cur[1]]) as [number, number];\n    const flatLast = aProjectFlat([last[0], last[1]]) as [number, number];\n    direction(lineA, flatCur, flatLast);\n    let segmentDistance = 0;\n    if (this.dash) {\n      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n      this.totalDistance += segmentDistance;\n    }\n\n    if (!this.normal) {\n      this.normal = vec2.create();\n      computeNormal(this.normal, lineA);\n    }\n    if (!this.started) {\n      this.started = true;\n\n      // if the end cap is type square, we can just push the verts out a bit\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.add(out1, this.normal, lineA);\n        vec2.add(out2, this.normal, lineA);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(\n          last[0],\n          last[1],\n          0,\n          this.totalDistance - segmentDistance,\n          -this.thickness,\n          0,\n        );\n        positions.push(\n          last[0],\n          last[1],\n          0,\n          this.totalDistance - segmentDistance,\n          this.thickness,\n          0,\n        );\n\n        // this.extrusions(positions, normals, last, out, this.thickness);\n        // last = capEnd;\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          last,\n          this.normal,\n          this.thickness,\n          this.totalDistance - segmentDistance,\n        );\n      }\n    }\n\n    indices.push(index + 0, index + 1, index + 2);\n\n    if (!next) {\n      computeNormal(this.normal, lineA);\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n        // cur = capEnd;\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.sub(out2, lineA, this.normal);\n        vec2.add(out1, lineA, this.normal);\n        // this.extrusions(positions, normals, cur, out, this.thickness);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(\n          cur[0],\n          cur[1],\n          0,\n          this.totalDistance,\n          this.thickness,\n          0,\n        );\n        positions.push(\n          cur[0],\n          cur[1],\n          0,\n          this.totalDistance,\n          this.thickness,\n          0,\n        );\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          cur,\n          this.normal,\n          this.thickness,\n          this.totalDistance,\n        );\n      }\n\n      // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n      indices.push(\n        ...(this.lastFlip === 1\n          ? [index, index + 2, index + 3]\n          : [index + 2, index + 1, index + 3]),\n      );\n      count += 2;\n    } else {\n      const flatNext = aProjectFlat([next[0], next[1]]) as [number, number];\n      if (isPointEqual(flatCur, flatNext)) {\n        vec2.add(\n          flatNext,\n          flatCur,\n          vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)),\n        );\n      }\n      direction(lineB, flatNext, flatCur);\n\n      // stores tangent & miter\n\n      const [miterLen, miter] = computeMiter(\n        tangent,\n        vec2.create(),\n        lineA,\n        lineB,\n        this.thickness,\n      );\n      // normal(tmp, lineA)\n\n      // get orientation\n      let flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n      let bevel = joinBevel;\n      if (!bevel && this.join === 'miter') {\n        const limit = miterLen;\n        if (limit > this.miterLimit) {\n          bevel = true;\n        }\n      }\n\n      if (bevel) {\n        normals.push(this.normal[0], this.normal[1], 0);\n        normals.push(miter[0], miter[1], 0);\n        positions.push(\n          cur[0],\n          cur[1],\n          0,\n          this.totalDistance,\n          -this.thickness * flip,\n          0,\n        );\n        positions.push(\n          cur[0],\n          cur[1],\n          0,\n          this.totalDistance,\n          this.thickness * flip,\n          0,\n        );\n        indices.push(\n          ...(this.lastFlip !== -flip\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3]),\n        );\n\n        // now add the bevel triangle\n        indices.push(index + 2, index + 3, index + 4);\n\n        computeNormal(tmp, lineB);\n        vec2.copy(this.normal, tmp); // store normal for next round\n        normals.push(this.normal[0], this.normal[1], 0);\n        positions.push(\n          cur[0],\n          cur[1],\n          0,\n          this.totalDistance,\n          -this.thickness * flip,\n          0,\n        );\n        count += 3;\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          cur,\n          miter,\n          miterLen,\n          this.totalDistance,\n        );\n        indices.push(\n          ...(this.lastFlip === 1\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3]),\n        );\n\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n      }\n      this.lastFlip = flip;\n    }\n    return count;\n  }\n\n  private extrusions(\n    positions: number[],\n    normals: number[],\n    point: vec2, // 顶点\n    normal: vec2, // 法向量\n    thickness: number, // 高度\n    distanceRadio: number,\n  ) {\n    normals.push(normal[0], normal[1], 0);\n    normals.push(normal[0], normal[1], 0);\n    positions.push(point[0], point[1], 0, distanceRadio, -thickness, 0);\n    positions.push(point[0], point[1], 0, distanceRadio, thickness, 0);\n  }\n  private lineSegmentDistance(b1: vec2, a1: vec2) {\n    const dx = a1[0] - b1[0];\n    const dy = a1[1] - b1[1];\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}\n"],"file":"extrude_polyline.js"}