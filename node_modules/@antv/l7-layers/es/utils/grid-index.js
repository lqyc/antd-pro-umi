import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var GridIndex = function () {
  function GridIndex(width, height, cellSize) {
    _classCallCheck(this, GridIndex);

    this.boxCells = [];
    this.xCellCount = void 0;
    this.yCellCount = void 0;
    this.boxKeys = void 0;
    this.bboxes = void 0;
    this.width = void 0;
    this.height = void 0;
    this.xScale = void 0;
    this.yScale = void 0;
    this.boxUid = void 0;
    var boxCells = this.boxCells;
    this.xCellCount = Math.ceil(width / cellSize);
    this.yCellCount = Math.ceil(height / cellSize);

    for (var i = 0; i < this.xCellCount * this.yCellCount; i++) {
      boxCells.push([]);
    }

    this.boxKeys = [];
    this.bboxes = [];
    this.width = width;
    this.height = height;
    this.xScale = this.xCellCount / width;
    this.yScale = this.yCellCount / height;
    this.boxUid = 0;
  }

  _createClass(GridIndex, [{
    key: "insert",
    value: function insert(key, x1, y1, x2, y2) {
      this.forEachCell(x1, y1, x2, y2, this.insertBoxCell, this.boxUid++);
      this.boxKeys.push(key);
      this.bboxes.push(x1);
      this.bboxes.push(y1);
      this.bboxes.push(x2);
      this.bboxes.push(y2);
    }
  }, {
    key: "query",
    value: function query(x1, y1, x2, y2, predicate) {
      return this.queryHitTest(x1, y1, x2, y2, false, predicate);
    }
  }, {
    key: "hitTest",
    value: function hitTest(x1, y1, x2, y2, predicate) {
      return this.queryHitTest(x1, y1, x2, y2, true, predicate);
    }
  }, {
    key: "insertBoxCell",
    value: function insertBoxCell(x1, y1, x2, y2, cellIndex, uid) {
      this.boxCells[cellIndex].push(uid);
    }
  }, {
    key: "queryHitTest",
    value: function queryHitTest(x1, y1, x2, y2, hitTest, predicate) {
      if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
        return hitTest ? false : [];
      }

      var result = [];

      if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {
        if (hitTest) {
          return true;
        }

        for (var boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {
          result.push({
            key: this.boxKeys[boxUid],
            x1: this.bboxes[boxUid * 4],
            y1: this.bboxes[boxUid * 4 + 1],
            x2: this.bboxes[boxUid * 4 + 2],
            y2: this.bboxes[boxUid * 4 + 3]
          });
        }

        return predicate ? result.filter(predicate) : result;
      }

      var queryArgs = {
        hitTest: hitTest,
        seenUids: {
          box: {},
          circle: {}
        }
      };
      this.forEachCell(x1, y1, x2, y2, this.queryCell, result, queryArgs, predicate);
      return hitTest ? result.length > 0 : result;
    }
  }, {
    key: "queryCell",
    value: function queryCell(x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {
      var seenUids = queryArgs.seenUids;
      var boxCell = this.boxCells[cellIndex];

      if (boxCell !== null) {
        var bboxes = this.bboxes;

        var _iterator = _createForOfIteratorHelper(boxCell),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var boxUid = _step.value;

            if (!seenUids.box[boxUid]) {
              seenUids.box[boxUid] = true;
              var offset = boxUid * 4;

              if (x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1] && (!predicate || predicate(this.boxKeys[boxUid]))) {
                if (queryArgs.hitTest) {
                  result.push(true);
                  return true;
                }

                result.push({
                  key: this.boxKeys[boxUid],
                  x1: bboxes[offset],
                  y1: bboxes[offset + 1],
                  x2: bboxes[offset + 2],
                  y2: bboxes[offset + 3]
                });
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return false;
    }
  }, {
    key: "forEachCell",
    value: function forEachCell(x1, y1, x2, y2, fn, arg1, arg2, predicate) {
      var cx1 = this.convertToXCellCoord(x1);
      var cy1 = this.convertToYCellCoord(y1);
      var cx2 = this.convertToXCellCoord(x2);
      var cy2 = this.convertToYCellCoord(y2);

      for (var x = cx1; x <= cx2; x++) {
        for (var y = cy1; y <= cy2; y++) {
          var cellIndex = this.xCellCount * y + x;

          if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {
            return;
          }
        }
      }
    }
  }, {
    key: "convertToXCellCoord",
    value: function convertToXCellCoord(x) {
      return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));
    }
  }, {
    key: "convertToYCellCoord",
    value: function convertToYCellCoord(y) {
      return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));
    }
  }]);

  return GridIndex;
}();

export default GridIndex;
//# sourceMappingURL=grid-index.js.map