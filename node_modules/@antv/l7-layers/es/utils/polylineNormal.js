import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { aProjectFlat } from '@antv/l7-utils';
import { vec2 } from 'gl-matrix';
export function computeMiter(tangent, miter, lineA, lineB, halfThick) {
  vec2.add(tangent, lineA, lineB);
  vec2.normalize(tangent, tangent);
  miter = vec2.fromValues(-tangent[1], tangent[0]);
  var tmp = vec2.fromValues(-lineA[1], lineA[0]);
  return halfThick / vec2.dot(miter, tmp);
}
export function computeNormal(out, dir) {
  return vec2.set(out, -dir[1], dir[0]);
}
export function direction(out, a, b) {
  vec2.sub(out, a, b);
  vec2.normalize(out, out);
  return out;
}

function extrusions(positions, out, miters, point, normal, scale) {
  addNext(out, miters, normal, -scale);
  addNext(out, miters, normal, scale);
  positions.push(point[0], point[1], 0);
  positions.push(point[0], point[1], 0);
}

function addNext(out, miters, normal, length) {
  out.push(normal[0], normal[1], 0);
  miters.push(length);
}

function lineSegmentDistance(b1, a1) {
  var dx = a1[0] - b1[0];
  var dy = a1[1] - b1[1];
  return Math.sqrt(dx * dx + dy * dy);
}

function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

export default function (points, closed, indexOffset) {
  var isDash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var lineA = vec2.fromValues(0, 0);
  var lineB = vec2.fromValues(0, 0);
  var tangent = vec2.fromValues(0, 0);
  var miter = vec2.create();
  var started = false;
  var lineNormal = null;
  var tmp = vec2.create();
  var count = indexOffset || 0;
  var miterLimit = 4;
  var out = [];
  var attrPos = [];
  var attrIndex = [];
  var miters = [];
  var attrDistance = [0, 0];

  if (closed) {
    points = points.slice();
    points.push(points[0]);
  }

  var total = points.length;

  for (var i = 1; i < total; i++) {
    var index = count;
    var last = vec2.fromValues(points[i - 1][0], points[i - 1][1]);
    var cur = vec2.fromValues(points[i][0], points[i][1]);
    var next = i < points.length - 1 ? vec2.fromValues(points[i + 1][0], points[i + 1][1]) : null;

    if (isPointEqual(last, cur)) {
      continue;
    }

    if (next) {
      var nextIndex = i + 1;

      while (next && isPointEqual(cur, next)) {
        next = nextIndex < points.length - 1 ? vec2.fromValues(points[++nextIndex][0], points[nextIndex][1]) : null;
      }
    }

    var d = 0;
    var flatCur = aProjectFlat([cur[0], cur[1]]);
    var flatLast = aProjectFlat([last[0], last[1]]);

    if (isDash) {
      var lineDistance = lineSegmentDistance(flatCur, flatLast);
      d = lineDistance + attrDistance[attrDistance.length - 1];
    }

    direction(lineA, flatCur, flatLast);

    if (!lineNormal) {
      lineNormal = vec2.create();
      computeNormal(lineNormal, lineA);
    }

    if (!started) {
      started = true;
      extrusions(attrPos, out, miters, last, lineNormal, 1);
    }

    attrIndex.push(index + 0, index + 2, index + 1);

    if (!next) {
      computeNormal(lineNormal, lineA);
      extrusions(attrPos, out, miters, cur, lineNormal, 1);
      attrDistance.push(d, d);
      attrIndex.push(index + 1, index + 2, index + 3);
      count += 2;
    } else {
      var flatNext = aProjectFlat([next[0], next[1]]);
      direction(lineB, flatNext, flatCur);
      var miterLen = computeMiter(tangent, vec2.fromValues(miter[0], miter[1]), lineA, lineB, 1);
      var flip = vec2.dot(tangent, lineNormal) < 0 ? -1 : 1;
      var bevel = Math.abs(miterLen) > miterLimit;

      if (Math.abs(miterLen) > 1000) {
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        attrIndex.push(index + 2, index + 4, index + 3);
        computeNormal(tmp, lineB);
        vec2.copy(lineNormal, tmp);
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d);
        count += 4;
        continue;
      }

      if (bevel) {
        miterLen = miterLimit;
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        attrIndex.push.apply(attrIndex, _toConsumableArray(flip === 1 ? [index + 2, index + 4, index + 5] : [index + 4, index + 5, index + 3]));
        computeNormal(tmp, lineB);
        vec2.copy(lineNormal, tmp);
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d);
        count += 4;
      } else {
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        addNext(out, miters, lineNormal, miterLen * -flip);
        attrPos.push(cur[0], cur[1], 0);
        attrIndex.push(index + 2, index + 4, index + 3);
        attrIndex.push(index + 4, index + 5, index + 6);
        computeNormal(tmp, lineB);
        vec2.copy(lineNormal, tmp);
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d, d);
        count += 5;
      }
    }
  }

  var pickData = [];

  for (var _i = 0; _i < miters.length; _i++) {
    var totalDistance = attrDistance[attrDistance.length - 1];
    pickData.push(attrPos[_i * 3], attrPos[_i * 3 + 1], attrPos[_i * 3 + 2], attrDistance[_i], miters[_i], totalDistance);
  }

  return {
    normals: out,
    attrIndex: attrIndex,
    attrPos: pickData
  };
}
//# sourceMappingURL=polylineNormal.js.map