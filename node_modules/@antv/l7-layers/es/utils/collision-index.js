import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { mat4, vec4 } from 'gl-matrix';
import GridIndex from './grid-index';

var CollisionIndex = function () {
  function CollisionIndex(width, height) {
    _classCallCheck(this, CollisionIndex);

    this.width = void 0;
    this.height = void 0;
    this.grid = void 0;
    this.viewportPadding = 100;
    this.screenRightBoundary = void 0;
    this.screenBottomBoundary = void 0;
    this.gridRightBoundary = void 0;
    this.gridBottomBoundary = void 0;
    this.width = width;
    this.height = height;
    this.viewportPadding = Math.max(width, height);
    this.grid = new GridIndex(width + this.viewportPadding, height + this.viewportPadding, 25);
    this.screenRightBoundary = width + this.viewportPadding;
    this.screenBottomBoundary = height + this.viewportPadding;
    this.gridRightBoundary = width + 2 * this.viewportPadding;
    this.gridBottomBoundary = height + 2 * this.viewportPadding;
  }

  _createClass(CollisionIndex, [{
    key: "placeCollisionBox",
    value: function placeCollisionBox(collisionBox) {
      var tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;
      var tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;
      var brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;
      var brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;

      if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {
        return {
          box: []
        };
      }

      return {
        box: [tlX, tlY, brX, brY]
      };
    }
  }, {
    key: "insertCollisionBox",
    value: function insertCollisionBox(box, featureIndex) {
      var key = {
        featureIndex: featureIndex
      };
      this.grid.insert(key, box[0], box[1], box[2], box[3]);
    }
  }, {
    key: "project",
    value: function project(mvpMatrix, x, y) {
      var point = vec4.fromValues(x, y, 0, 1);
      var out = vec4.create();
      var mat = mat4.fromValues.apply(mat4, _toConsumableArray(mvpMatrix));
      vec4.transformMat4(out, point, mat);
      return {
        x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,
        y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding
      };
    }
  }, {
    key: "isInsideGrid",
    value: function isInsideGrid(x1, y1, x2, y2) {
      return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
    }
  }]);

  return CollisionIndex;
}();

export { CollisionIndex as default };
//# sourceMappingURL=collision-index.js.map