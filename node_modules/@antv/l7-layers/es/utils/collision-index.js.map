{"version":3,"sources":["../../src/utils/collision-index.ts"],"names":["mat4","vec4","GridIndex","CollisionIndex","width","height","grid","viewportPadding","screenRightBoundary","screenBottomBoundary","gridRightBoundary","gridBottomBoundary","Math","max","collisionBox","tlX","x1","anchorPointX","tlY","y1","anchorPointY","brX","x2","brY","y2","isInsideGrid","hitTest","box","featureIndex","key","insert","mvpMatrix","x","y","point","fromValues","out","create","mat","transformMat4"],"mappings":";;;AASA,SAASA,IAAT,EAAeC,IAAf,QAA2B,WAA3B;AACA,OAAOC,SAAP,MAAsB,cAAtB;;IAKqBC,c;AASnB,0BAAYC,KAAZ,EAA2BC,MAA3B,EAA2C;AAAA;;AAAA,SARnCD,KAQmC;AAAA,SAPnCC,MAOmC;AAAA,SANnCC,IAMmC;AAAA,SALnCC,eAKmC,GALT,GAKS;AAAA,SAJnCC,mBAImC;AAAA,SAHnCC,oBAGmC;AAAA,SAFnCC,iBAEmC;AAAA,SADnCC,kBACmC;AACzC,SAAKP,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKE,eAAL,GAAuBK,IAAI,CAACC,GAAL,CAAST,KAAT,EAAgBC,MAAhB,CAAvB;AAEA,SAAKC,IAAL,GAAY,IAAIJ,SAAJ,CACVE,KAAK,GAAG,KAAKG,eADH,EAEVF,MAAM,GAAG,KAAKE,eAFJ,EAGV,EAHU,CAAZ;AAMA,SAAKC,mBAAL,GAA2BJ,KAAK,GAAG,KAAKG,eAAxC;AACA,SAAKE,oBAAL,GAA4BJ,MAAM,GAAG,KAAKE,eAA1C;AACA,SAAKG,iBAAL,GAAyBN,KAAK,GAAG,IAAI,KAAKG,eAA1C;AACA,SAAKI,kBAAL,GAA0BN,MAAM,GAAG,IAAI,KAAKE,eAA5C;AACD;;;;WAED,2BAAyBO,YAAzB,EAAsD;AAOpD,UAAMC,GAAG,GACPD,YAAY,CAACE,EAAb,GAAkBF,YAAY,CAACG,YAA/B,GAA8C,KAAKV,eADrD;AAEA,UAAMW,GAAG,GACPJ,YAAY,CAACK,EAAb,GAAkBL,YAAY,CAACM,YAA/B,GAA8C,KAAKb,eADrD;AAEA,UAAMc,GAAG,GACPP,YAAY,CAACQ,EAAb,GAAkBR,YAAY,CAACG,YAA/B,GAA8C,KAAKV,eADrD;AAEA,UAAMgB,GAAG,GACPT,YAAY,CAACU,EAAb,GAAkBV,YAAY,CAACM,YAA/B,GAA8C,KAAKb,eADrD;;AAGA,UACE,CAAC,KAAKkB,YAAL,CAAkBV,GAAlB,EAAuBG,GAAvB,EAA4BG,GAA5B,EAAiCE,GAAjC,CAAD,IACA,KAAKjB,IAAL,CAAUoB,OAAV,CAAkBX,GAAlB,EAAuBG,GAAvB,EAA4BG,GAA5B,EAAiCE,GAAjC,CAFF,EAGE;AACA,eAAO;AACLI,UAAAA,GAAG,EAAE;AADA,SAAP;AAGD;;AAED,aAAO;AACLA,QAAAA,GAAG,EAAE,CAACZ,GAAD,EAAMG,GAAN,EAAWG,GAAX,EAAgBE,GAAhB;AADA,OAAP;AAGD;;;WAED,4BAA0BI,GAA1B,EAAyCC,YAAzC,EAA+D;AAC7D,UAAMC,GAAG,GAAG;AAAED,QAAAA,YAAY,EAAZA;AAAF,OAAZ;AACA,WAAKtB,IAAL,CAAUwB,MAAV,CAAiBD,GAAjB,EAAsBF,GAAG,CAAC,CAAD,CAAzB,EAA8BA,GAAG,CAAC,CAAD,CAAjC,EAAsCA,GAAG,CAAC,CAAD,CAAzC,EAA8CA,GAAG,CAAC,CAAD,CAAjD;AACD;;;WASD,iBAAeI,SAAf,EAAoCC,CAApC,EAA+CC,CAA/C,EAA0D;AACxD,UAAMC,KAAK,GAAGjC,IAAI,CAACkC,UAAL,CAAgBH,CAAhB,EAAmBC,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAAd;AACA,UAAMG,GAAG,GAAGnC,IAAI,CAACoC,MAAL,EAAZ;AAEA,UAAMC,GAAG,GAAGtC,IAAI,CAACmC,UAAL,OAAAnC,IAAI,qBAAe+B,SAAf,EAAhB;AACA9B,MAAAA,IAAI,CAACsC,aAAL,CAAmBH,GAAnB,EAAwBF,KAAxB,EAA+BI,GAA/B;AAEA,aAAO;AACLN,QAAAA,CAAC,EAAG,CAACI,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAZ,GAAkB,CAAnB,IAAwB,CAAzB,GAA8B,KAAKhC,KAAnC,GAA2C,KAAKG,eAD9C;AAEL0B,QAAAA,CAAC,EAAG,CAAC,CAACG,GAAG,CAAC,CAAD,CAAJ,GAAUA,GAAG,CAAC,CAAD,CAAb,GAAmB,CAApB,IAAyB,CAA1B,GAA+B,KAAK/B,MAApC,GAA6C,KAAKE;AAFhD,OAAP;AAID;;;WAUD,sBAAoBS,EAApB,EAAgCG,EAAhC,EAA4CG,EAA5C,EAAwDE,EAAxD,EAAoE;AAClE,aACEF,EAAE,IAAI,CAAN,IACAN,EAAE,GAAG,KAAKN,iBADV,IAEAc,EAAE,IAAI,CAFN,IAGAL,EAAE,GAAG,KAAKR,kBAJZ;AAMD;;;;;;SAhGkBR,c","sourcesContent":["export interface ICollisionBox {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  anchorPointX: number;\n  anchorPointY: number;\n}\n// @mapbox/grid-index 并没有类似 hitTest 的单纯获取碰撞检测结果的方法，query 将导致计算大量多余的包围盒结果，因此使用改良版\nimport { mat4, vec4 } from 'gl-matrix';\nimport GridIndex from './grid-index';\n/**\n * 基于网格实现文本避让，大幅提升包围盒碰撞检测效率\n * @see https://zhuanlan.zhihu.com/p/74373214\n */\nexport default class CollisionIndex {\n  private width: number;\n  private height: number;\n  private grid: GridIndex;\n  private viewportPadding: number = 100;\n  private screenRightBoundary: number;\n  private screenBottomBoundary: number;\n  private gridRightBoundary: number;\n  private gridBottomBoundary: number;\n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n    this.viewportPadding = Math.max(width, height);\n    // 创建网格索引\n    this.grid = new GridIndex(\n      width + this.viewportPadding,\n      height + this.viewportPadding,\n      25,\n    );\n\n    this.screenRightBoundary = width + this.viewportPadding;\n    this.screenBottomBoundary = height + this.viewportPadding;\n    this.gridRightBoundary = width + 2 * this.viewportPadding;\n    this.gridBottomBoundary = height + 2 * this.viewportPadding;\n  }\n\n  public placeCollisionBox(collisionBox: ICollisionBox) {\n    // const projectedPoint = this.project(\n    //   mvpMatrix,\n    //   collisionBox.anchorPointX,\n    //   collisionBox.anchorPointY,\n    // );\n\n    const tlX =\n      collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;\n    const tlY =\n      collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;\n    const brX =\n      collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;\n    const brY =\n      collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;\n\n    if (\n      !this.isInsideGrid(tlX, tlY, brX, brY) ||\n      this.grid.hitTest(tlX, tlY, brX, brY)\n    ) {\n      return {\n        box: [],\n      };\n    }\n\n    return {\n      box: [tlX, tlY, brX, brY],\n    };\n  }\n\n  public insertCollisionBox(box: number[], featureIndex: number) {\n    const key = { featureIndex };\n    this.grid.insert(key, box[0], box[1], box[2], box[3]);\n  }\n\n  /**\n   * 后续碰撞检测都需要投影到 viewport 坐标系\n   * @param {THREE.Matrix4} mvpMatrix mvp矩阵\n   * @param {number} x P20 平面坐标X\n   * @param {number} y P20 平面坐标Y\n   * @return {Point} projectedPoint\n   */\n  public project(mvpMatrix: number[], x: number, y: number) {\n    const point = vec4.fromValues(x, y, 0, 1);\n    const out = vec4.create();\n    // @ts-ignore\n    const mat = mat4.fromValues(...mvpMatrix);\n    vec4.transformMat4(out, point, mat);\n    // GL 坐标系[-1, 1] -> viewport 坐标系[width, height]\n    return {\n      x: ((out[0] / out[3] + 1) / 2) * this.width + this.viewportPadding,\n      y: ((-out[1] / out[3] + 1) / 2) * this.height + this.viewportPadding,\n    };\n  }\n\n  /**\n   * 判断包围盒是否在整个网格内，需要加上 buffer\n   * @param {number} x1 x1\n   * @param {number} y1 y1\n   * @param {number} x2 x2\n   * @param {number} y2 y2\n   * @return {Point} isInside\n   */\n  public isInsideGrid(x1: number, y1: number, x2: number, y2: number) {\n    return (\n      x2 >= 0 &&\n      x1 < this.gridRightBoundary &&\n      y2 >= 0 &&\n      y1 < this.gridBottomBoundary\n    );\n  }\n}\n"],"file":"collision-index.js"}