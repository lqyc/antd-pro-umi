import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import earcut from 'earcut';
export default function extrudePolygon(path) {
  var p1 = path[0][0];
  var p2 = path[0][path[0].length - 1];

  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    path[0] = path[0].slice(0, path[0].length - 1);
  }

  var n = path[0].length;
  var flattengeo = earcut.flatten(path);
  var positions = [];
  var indexArray = [];
  var normals = [];

  for (var j = 0; j < flattengeo.vertices.length / 3; j++) {
    flattengeo.vertices[j * 3 + 2] = 1;
    normals.push(0, 0, 1);
  }

  positions.push.apply(positions, _toConsumableArray(flattengeo.vertices));
  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  indexArray.push.apply(indexArray, _toConsumableArray(triangles));

  var _loop = function _loop(i) {
    var prePoint = flattengeo.vertices.slice(i * 3, i * 3 + 3);
    var nextPoint = flattengeo.vertices.slice(i * 3 + 3, i * 3 + 6);

    if (nextPoint.length === 0) {
      nextPoint = flattengeo.vertices.slice(0, 3);
    }

    var indexOffset = positions.length / 3;
    positions.push(prePoint[0], prePoint[1], 1, nextPoint[0], nextPoint[1], 1, prePoint[0], prePoint[1], 0, nextPoint[0], nextPoint[1], 0);
    indexArray.push.apply(indexArray, _toConsumableArray([1, 2, 0, 3, 2, 1].map(function (v) {
      return v + indexOffset;
    })));
  };

  for (var i = 0; i < n; i++) {
    _loop(i);
  }

  return {
    positions: positions,
    index: indexArray
  };
}
export function fillPolygon(points) {
  var flattengeo = earcut.flatten(points);
  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  return {
    positions: flattengeo.vertices,
    index: triangles
  };
}
//# sourceMappingURL=extrude.js.map