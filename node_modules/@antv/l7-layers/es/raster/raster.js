import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { gl } from '@antv/l7-core';
import { generateColorRamp } from '@antv/l7-utils';
import BaseLayer from '../core/BaseLayer';
import { RasterTriangulation } from './buffers/triangulation';
var rasterFrag = "varying vec4 v_color;\nuniform float u_opacity: 1.0;\n#define PI 3.141592653589793\n\nvoid main() {\n   gl_FragColor = v_color;\n   gl_FragColor.a *= u_opacity;\n\n}\n";
var rasterVert = "precision highp float;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform vec4 u_extent;\nuniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform float u_min;\nuniform float u_max;\nuniform float u_width;\nuniform float u_height;\nuniform float u_heightRatio;\n\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\n#pragma include \"projection\"\nvoid main() {\n  vec2 uv = a_Position.xy / vec2(u_width, u_height);\n  vec2 minxy =  project_position(vec4(u_extent.xy, 0, 1.0)).xy;\n  vec2 maxxy =  project_position(vec4(u_extent.zw, 0, 1.0)).xy;\n  float value = texture2D(u_texture, vec2(uv.x,1.0 - uv.y)).x;\n  vec2 step = (maxxy - minxy) / vec2(u_width, u_height);\n  vec2 pos = minxy + vec2(a_Position.x, a_Position.y ) * step;\n  //  v_texCoord = a_Uv;\n  value = clamp(value,u_min,u_max);\n  float value1 =  (value - u_min) / (u_max -u_min);\n  vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\n\n  // if(uv.x > 1.0 || uv.y > 1.0) {\n  //   v_color = vec4(0.);\n  // }\n\n  //  vec2 range = u_extent.zw - u_extent.xy;\n  //  vec4 project_pos = project_position(vec4(pos, 0, 1.0));\n   gl_Position = project_common_position_to_clipspace(vec4(pos.xy, project_scale(value) * u_heightRatio, 1.0));\n\n}\n";

var RasterLayer = function (_BaseLayer) {
  _inherits(RasterLayer, _BaseLayer);

  var _super = _createSuper(RasterLayer);

  function RasterLayer() {
    var _this;

    _classCallCheck(this, RasterLayer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.type = 'RasterLayer';
    _this.texture = void 0;
    _this.colorTexture = void 0;
    return _this;
  }

  _createClass(RasterLayer, [{
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      return {};
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var parserDataItem = this.getSource().data.dataArray[0];
      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        data: parserDataItem.data,
        width: parserDataItem.width,
        height: parserDataItem.height,
        format: gl.LUMINANCE,
        type: gl.FLOAT,
        aniso: 4
      });

      var _this$getLayerConfig = this.getLayerConfig(),
          rampColors = _this$getLayerConfig.rampColors;

      var imageData = generateColorRamp(rampColors);
      this.colorTexture = createTexture2D({
        data: imageData.data,
        width: imageData.width,
        height: imageData.height,
        flipY: false
      });
      this.models = [this.buildRasterModel()];
    }
  }, {
    key: "renderModels",
    value: function renderModels() {
      var _this2 = this;

      var _this$getLayerConfig2 = this.getLayerConfig(),
          opacity = _this$getLayerConfig2.opacity,
          _this$getLayerConfig3 = _this$getLayerConfig2.heightRatio,
          heightRatio = _this$getLayerConfig3 === void 0 ? 10 : _this$getLayerConfig3;

      var parserDataItem = this.getSource().data.dataArray[0];
      var coordinates = parserDataItem.coordinates,
          width = parserDataItem.width,
          height = parserDataItem.height,
          min = parserDataItem.min,
          max = parserDataItem.max;
      this.models.forEach(function (model) {
        return model.draw({
          uniforms: {
            u_opacity: opacity || 1,
            u_texture: _this2.texture,
            u_min: min,
            u_width: width,
            u_height: height,
            u_max: max,
            u_heightRatio: heightRatio,
            u_colorTexture: _this2.colorTexture,
            u_extent: [].concat(_toConsumableArray(coordinates[0]), _toConsumableArray(coordinates[1]))
          }
        });
      });
      return this;
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "buildRasterModel",
    value: function buildRasterModel() {
      var source = this.getSource();
      var sourceFeature = source.data.dataArray[0];
      var triangulation = RasterTriangulation(sourceFeature);
      this.shaderModuleService.registerModule('raster', {
        vs: rasterVert,
        fs: rasterFrag
      });

      var _this$shaderModuleSer = this.shaderModuleService.getModule('raster'),
          vs = _this$shaderModuleSer.vs,
          fs = _this$shaderModuleSer.fs,
          uniforms = _this$shaderModuleSer.uniforms;

      var _this$rendererService = this.rendererService,
          createAttribute = _this$rendererService.createAttribute,
          createElements = _this$rendererService.createElements,
          createBuffer = _this$rendererService.createBuffer,
          createModel = _this$rendererService.createModel;
      return createModel({
        vs: vs,
        fs: fs,
        attributes: {
          a_Position: createAttribute({
            buffer: createBuffer({
              data: triangulation.vertices,
              type: gl.FLOAT
            }),
            size: 2
          })
        },
        primitive: gl.TRIANGLES,
        uniforms: _objectSpread({}, uniforms),
        depth: {
          enable: true
        },
        elements: createElements({
          data: triangulation.indices,
          type: gl.UNSIGNED_INT,
          count: triangulation.indices.length
        })
      });
    }
  }]);

  return RasterLayer;
}(BaseLayer);

export { RasterLayer as default };
//# sourceMappingURL=raster.js.map