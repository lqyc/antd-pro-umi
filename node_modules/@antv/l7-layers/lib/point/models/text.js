"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextTriangulation = TextTriangulation;
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _l7Core = require("@antv/l7-core");

var _l7Utils = require("@antv/l7-utils");

var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));

var _collisionIndex = _interopRequireDefault(require("../../utils/collision-index"));

var _geo = require("../../utils/geo");

var _symbolLayout = require("../../utils/symbol-layout");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var textFrag = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\n// uniform float u_font_size : 24.0;\nuniform float u_opacity : 1.0;\nuniform float u_stroke_opacity: 1.0;\nuniform vec4 u_stroke : [0, 0, 0, 1];\nuniform float u_strokeWidth : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\n\n#pragma include \"picking\"\nvoid main() {\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  // float fontScale = u_font_size / FONT_SIZE;\n\n  lowp float buff = (6.0 - u_strokeWidth / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), vec4(u_stroke.rgb, u_stroke.a * u_opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor.a= gl_FragColor.a * alpha;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var textVert = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 24.0\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\nattribute vec4 a_Color;\nattribute float a_Size;\nattribute float a_Rotate;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying vec4 v_color;\nvarying float v_fontScale;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  v_color = a_Color;\n  v_uv = a_tex / u_sdf_map_size;\n\n  // \u6587\u672C\u7F29\u653E\u6BD4\u4F8B\n  float fontScale = a_Size / FONT_SIZE;\n   v_fontScale = fontScale;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n highp float angle_sin = sin(a_Rotate);\n highp float angle_cos = cos(a_Rotate);\n mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  gl_Position = vec4(projected_position.xy / projected_position.w\n    + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n";

function TextTriangulation(feature) {
  var that = this;
  var id = feature.id;
  var vertices = [];
  var indices = [];

  if (!that.glyphInfoMap || !that.glyphInfoMap[id]) {
    return {
      vertices: [],
      indices: [],
      size: 7
    };
  }

  var centroid = that.glyphInfoMap[id].centroid;
  var coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;
  that.glyphInfoMap[id].glyphQuads.forEach(function (quad, index) {
    vertices.push.apply(vertices, (0, _toConsumableArray2.default)(coord).concat([quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y]));
    indices.push(0 + index * 4, 1 + index * 4, 2 + index * 4, 2 + index * 4, 3 + index * 4, 0 + index * 4);
  });
  return {
    vertices: vertices,
    indices: indices,
    size: 7
  };
}

var TextModel = function (_BaseModel) {
  (0, _inherits2.default)(TextModel, _BaseModel);

  var _super = _createSuper(TextModel);

  function TextModel() {
    var _this;

    (0, _classCallCheck2.default)(this, TextModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.glyphInfo = void 0;
    _this.glyphInfoMap = {};
    _this.texture = void 0;
    _this.currentZoom = -1;
    _this.extent = void 0;
    _this.textureHeight = 0;
    _this.textCount = 0;
    _this.preTextStyle = {};

    _this.buildModels = function () {
      _this.initGlyph();

      _this.updateTexture();

      _this.filterGlyphs();

      return [_this.layer.buildLayerModel({
        moduleName: 'pointText',
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTriangulation.bind((0, _assertThisInitialized2.default)(_this)),
        depth: {
          enable: false
        },
        blend: _this.getBlend()
      })];
    };

    return _this;
  }

  (0, _createClass2.default)(TextModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1.0 : _ref$opacity,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          _ref$textAnchor = _ref.textAnchor,
          textAnchor = _ref$textAnchor === void 0 ? 'center' : _ref$textAnchor,
          _ref$textAllowOverlap = _ref.textAllowOverlap,
          textAllowOverlap = _ref$textAllowOverlap === void 0 ? false : _ref$textAllowOverlap,
          _ref$halo = _ref.halo,
          halo = _ref$halo === void 0 ? 0.5 : _ref$halo,
          _ref$gamma = _ref.gamma,
          gamma = _ref$gamma === void 0 ? 2.0 : _ref$gamma;

      var _this$fontService = this.fontService,
          canvas = _this$fontService.canvas,
          mapping = _this$fontService.mapping;

      if (Object.keys(mapping).length !== this.textCount) {
        this.updateTexture();
        this.textCount = Object.keys(mapping).length;
      }

      this.preTextStyle = {
        textAnchor: textAnchor,
        textAllowOverlap: textAllowOverlap
      };
      return {
        u_opacity: opacity,
        u_stroke_opacity: strokeOpacity,
        u_sdf_map: this.texture,
        u_stroke: (0, _l7Utils.rgb2arr)(stroke),
        u_halo_blur: halo,
        u_gamma_scale: gamma,
        u_sdf_map_size: [canvas.width, canvas.height],
        u_strokeWidth: strokeWidth
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.layer.on('remapping', this.buildModels);
      this.extent = this.textExtent();

      var _ref2 = this.layer.getLayerConfig(),
          _ref2$textAnchor = _ref2.textAnchor,
          textAnchor = _ref2$textAnchor === void 0 ? 'center' : _ref2$textAnchor,
          _ref2$textAllowOverla = _ref2.textAllowOverlap,
          textAllowOverlap = _ref2$textAllowOverla === void 0 ? true : _ref2$textAllowOverla;

      this.preTextStyle = {
        textAnchor: textAnchor,
        textAllowOverlap: textAllowOverlap
      };
      return this.buildModels();
    }
  }, {
    key: "needUpdate",
    value: function needUpdate() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$textAllowOverla = _ref3.textAllowOverlap,
          textAllowOverlap = _ref3$textAllowOverla === void 0 ? false : _ref3$textAllowOverla;

      var zoom = this.mapService.getZoom();
      var extent = this.mapService.getBounds();
      var flag = (0, _l7Utils.boundsContains)(this.extent, extent);

      if (!textAllowOverlap && (Math.abs(this.currentZoom - zoom) > 1 || !flag) || textAllowOverlap !== this.preTextStyle.textAllowOverlap) {
        this.reBuildModel();
        return true;
      }

      return false;
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      this.layer.off('remapping', this.buildModels);
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'rotate',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Rotate',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$rotate = feature.rotate,
                rotate = _feature$rotate === void 0 ? 0 : _feature$rotate;
            return Array.isArray(rotate) ? [rotate[0]] : [rotate];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textOffsets',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_textOffsets',
          buffer: {
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 12 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textUv',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_tex',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "textExtent",
    value: function textExtent() {
      var bounds = this.mapService.getBounds();
      return (0, _l7Utils.padBounds)(bounds, 0.5);
    }
  }, {
    key: "initTextFont",
    value: function initTextFont() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$fontWeight = _ref4.fontWeight,
          fontWeight = _ref4$fontWeight === void 0 ? '400' : _ref4$fontWeight,
          _ref4$fontFamily = _ref4.fontFamily,
          fontFamily = _ref4$fontFamily === void 0 ? 'sans-serif' : _ref4$fontFamily;

      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape = item.shape,
            shape = _item$shape === void 0 ? '' : _item$shape;
        shape = shape.toString();

        var _iterator = _createForOfIteratorHelper(shape),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var char = _step.value;

            if (characterSet.indexOf(char) === -1) {
              characterSet.push(char);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily
      });
    }
  }, {
    key: "generateGlyphLayout",
    value: function generateGlyphLayout() {
      var _this2 = this;

      var mapping = this.fontService.mapping;

      var _ref5 = this.layer.getLayerConfig(),
          _ref5$spacing = _ref5.spacing,
          spacing = _ref5$spacing === void 0 ? 2 : _ref5$spacing,
          _ref5$textAnchor = _ref5.textAnchor,
          textAnchor = _ref5$textAnchor === void 0 ? 'center' : _ref5$textAnchor,
          textOffset = _ref5.textOffset;

      var data = this.layer.getEncodedData();
      this.glyphInfo = data.map(function (feature) {
        var _feature$shape = feature.shape,
            shape = _feature$shape === void 0 ? '' : _feature$shape,
            coordinates = feature.coordinates,
            id = feature.id,
            _feature$size2 = feature.size,
            size = _feature$size2 === void 0 ? 1 : _feature$size2;
        var shaping = (0, _symbolLayout.shapeText)(shape.toString(), mapping, size, textAnchor, 'center', spacing, textOffset);
        var glyphQuads = (0, _symbolLayout.getGlyphQuads)(shaping, textOffset, false);
        feature.shaping = shaping;
        feature.glyphQuads = glyphQuads;
        feature.centroid = (0, _geo.calculteCentroid)(coordinates);
        _this2.glyphInfoMap[id] = {
          shaping: shaping,
          glyphQuads: glyphQuads,
          centroid: (0, _geo.calculteCentroid)(coordinates)
        };
        return feature;
      });
    }
  }, {
    key: "filterGlyphs",
    value: function filterGlyphs() {
      var _this3 = this;

      var _ref6 = this.layer.getLayerConfig(),
          _ref6$padding = _ref6.padding,
          padding = _ref6$padding === void 0 ? [4, 4] : _ref6$padding,
          _ref6$textAllowOverla = _ref6.textAllowOverlap,
          textAllowOverlap = _ref6$textAllowOverla === void 0 ? false : _ref6$textAllowOverla;

      if (textAllowOverlap) {
        return;
      }

      this.glyphInfoMap = {};
      this.currentZoom = this.mapService.getZoom();
      this.extent = this.textExtent();

      var _this$rendererService = this.rendererService.getViewportSize(),
          width = _this$rendererService.width,
          height = _this$rendererService.height;

      var collisionIndex = new _collisionIndex.default(width, height);
      var filterData = this.glyphInfo.filter(function (feature) {
        var shaping = feature.shaping,
            _feature$id = feature.id,
            id = _feature$id === void 0 ? 0 : _feature$id;
        var centroid = feature.centroid;
        var size = feature.size;
        var fontScale = size / 24;

        var pixels = _this3.mapService.lngLatToContainer(centroid);

        var _collisionIndex$place = collisionIndex.placeCollisionBox({
          x1: shaping.left * fontScale - padding[0],
          x2: shaping.right * fontScale + padding[0],
          y1: shaping.top * fontScale - padding[1],
          y2: shaping.bottom * fontScale + padding[1],
          anchorPointX: pixels.x,
          anchorPointY: pixels.y
        }),
            box = _collisionIndex$place.box;

        if (box && box.length) {
          collisionIndex.insertCollisionBox(box, id);
          return true;
        } else {
          return false;
        }
      });
      filterData.forEach(function (item) {
        _this3.glyphInfoMap[item.id] = item;
      });
    }
  }, {
    key: "initGlyph",
    value: function initGlyph() {
      this.initTextFont();
      this.generateGlyphLayout();
    }
  }, {
    key: "updateTexture",
    value: function updateTexture() {
      var createTexture2D = this.rendererService.createTexture2D;
      var canvas = this.fontService.canvas;
      this.textureHeight = canvas.height;

      if (this.texture) {
        this.texture.destroy();
      }

      this.texture = createTexture2D({
        data: canvas,
        mag: _l7Core.gl.LINEAR,
        min: _l7Core.gl.LINEAR,
        width: canvas.width,
        height: canvas.height
      });
    }
  }, {
    key: "reBuildModel",
    value: function reBuildModel() {
      this.filterGlyphs();
      this.layer.models = [this.layer.buildLayerModel({
        moduleName: 'pointText',
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTriangulation.bind(this),
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }]);
  return TextModel;
}(_BaseModel2.default);

exports.default = TextModel;
//# sourceMappingURL=text.js.map