"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _l7Core = require("@antv/l7-core");

var _l7Utils = require("@antv/l7-utils");

var _glMatrix = require("gl-matrix");

var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));

var _triangulation = require("../../core/triangulation");

var _triangulation2 = require("../triangulation");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var heatmap3DFrag = "uniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform float u_opacity;\nvarying vec2 v_texCoord;\nvarying float v_intensity;\n\nvoid main(){\n   \n     float intensity = texture2D(u_texture, v_texCoord).r;\n    vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\n    gl_FragColor = color;\n    // gl_FragColor.a = color.a * smoothstep(0.1,0.2,intensity)* u_opacity;\n     gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n\n}\n";
var heatmap3DVert = "precision highp float;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_InverseViewProjectionMatrix;\nuniform mat4 u_ViewProjectionMatrixUncentered;\nvarying float v_intensity;\n\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n    float t2 = t * t;\n    float one_minus_t = 1.0 - t;\n    float one_minus_t2 = one_minus_t * one_minus_t;\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t);\n}\nvec2 toBezier(float t, vec4 p){\n    return toBezier(t, vec2(0.0, 0.0), vec2(p.x, p.y), vec2(p.z, p.w), vec2(1.0, 1.0));\n}\n#pragma include \"projection\"\nvoid main() {\n  v_texCoord = a_Uv;\n\n  vec2 pos =(a_Uv * vec2(2.0) - vec2(1.0));\n\n\n  vec4 p1 = vec4(pos, 0.0, 1.0);\n\tvec4 p2 = vec4(pos, 1.0, 1.0);\n\n\tvec4 inverseP1 = u_InverseViewProjectionMatrix * p1;\n\tvec4 inverseP2 = u_InverseViewProjectionMatrix * p2;\n\n  inverseP1 = inverseP1 / inverseP1.w;\n\tinverseP2 = inverseP2 / inverseP2.w;\n\n\tfloat zPos = (0.0 - inverseP1.z) / (inverseP2.z - inverseP1.z);\n\tvec4 position = inverseP1 + zPos * (inverseP2 - inverseP1);\n\n  vec4 b= vec4(0.5000, 0, 1, 0.5000);\n  float fh;\n\n  v_intensity = texture2D(u_texture, v_texCoord).r;\n  fh = toBezier(v_intensity, b).y;\n  gl_Position = u_ViewProjectionMatrixUncentered * vec4(position.xy, fh * project_pixel(50.), 1.0);\n\n}\n";
var heatmapColorFrag = "uniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\nuniform float u_opacity;\nvarying vec2 v_texCoord;\nvarying float v_intensity;\n\nvoid main(){\n     float intensity = texture2D(u_texture, v_texCoord).r;\n    vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\n    gl_FragColor =color;\n    gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n\n}\n";
var heatmapFrag = "precision highp float;\nuniform float u_intensity;\nvarying float v_weight;\nvarying vec2 v_extrude;\n#define GAUSS_COEF  0.3989422804014327\nvoid main(){\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\n    float val = v_weight * u_intensity * GAUSS_COEF * exp(d);\n    gl_FragColor = vec4(val, 1., 1., 1.);\n}\n";
var heatmapVert = "precision highp float;\nattribute vec3 a_Position;\nattribute float a_Size;\nattribute vec2 a_Dir;\nuniform float u_intensity;\nuniform float u_radius;\nvarying vec2 v_extrude;\nvarying float v_weight;\nuniform mat4 u_ModelMatrix;\n\n#define GAUSS_COEF  0.3989422804014327\n\n#pragma include \"projection\"\n\nvoid main(){\n    v_weight = a_Size;\n    float ZERO = 1.0 / 255.0 / 16.0;\n    float extrude_x = a_Dir.x * 2.0 -1.0;\n    float extrude_y = a_Dir.y * 2.0 -1.0;\n    vec2 extrude_dir = normalize(vec2(extrude_x,extrude_y));\n    float S = sqrt(-2.0 * log(ZERO / a_Size / u_intensity / GAUSS_COEF)) / 3.0;\n    v_extrude = extrude_dir * S;\n\n    vec2 offset = project_pixel(v_extrude * u_radius);\n    vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n}\n";
var heatmapColorVert = "precision highp float;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nvarying float v_intensity;\nvoid main() {\n  v_texCoord = a_Uv;\n  v_intensity = texture2D(u_texture, v_texCoord).r;\n  gl_Position = vec4(a_Position.xy, 0, 1.);\n}\n";

var HeatMapModel = function (_BaseModel) {
  (0, _inherits2.default)(HeatMapModel, _BaseModel);

  var _super = _createSuper(HeatMapModel);

  function HeatMapModel() {
    var _this;

    (0, _classCallCheck2.default)(this, HeatMapModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.texture = void 0;
    _this.colorTexture = void 0;
    _this.heatmapFramerBuffer = void 0;
    _this.intensityModel = void 0;
    _this.colorModel = void 0;
    _this.shapeType = void 0;
    return _this;
  }

  (0, _createClass2.default)(HeatMapModel, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$rendererService = this.rendererService,
          clear = _this$rendererService.clear,
          useFramebuffer = _this$rendererService.useFramebuffer;
      useFramebuffer(this.heatmapFramerBuffer, function () {
        clear({
          color: [0, 0, 0, 0],
          depth: 1,
          stencil: 0,
          framebuffer: _this2.heatmapFramerBuffer
        });

        _this2.drawIntensityMode();
      });

      if (this.layer.styleNeedUpdate) {
        this.updateColorTexture();
      }

      this.shapeType === 'heatmap' ? this.drawColorMode() : this.draw3DHeatMap();
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _shapeAttr$scale;

      var _this$rendererService2 = this.rendererService,
          createFramebuffer = _this$rendererService2.createFramebuffer,
          clear = _this$rendererService2.clear,
          getViewportSize = _this$rendererService2.getViewportSize,
          createTexture2D = _this$rendererService2.createTexture2D,
          useFramebuffer = _this$rendererService2.useFramebuffer;
      var shapeAttr = this.styleAttributeService.getLayerStyleAttribute('shape');
      var shapeType = (shapeAttr === null || shapeAttr === void 0 ? void 0 : (_shapeAttr$scale = shapeAttr.scale) === null || _shapeAttr$scale === void 0 ? void 0 : _shapeAttr$scale.field) || 'heatmap';
      this.shapeType = shapeType;
      this.intensityModel = this.buildHeatMapIntensity();
      this.colorModel = shapeType === 'heatmap' ? this.buildHeatmapColor() : this.build3dHeatMap();

      var _ref = this.layer.getLayerConfig(),
          rampColors = _ref.rampColors;

      var imageData = (0, _l7Utils.generateColorRamp)(rampColors);

      var _getViewportSize = getViewportSize(),
          width = _getViewportSize.width,
          height = _getViewportSize.height;

      this.heatmapFramerBuffer = createFramebuffer({
        color: createTexture2D({
          width: Math.floor(width / 4),
          height: Math.floor(height / 4),
          wrapS: _l7Core.gl.CLAMP_TO_EDGE,
          wrapT: _l7Core.gl.CLAMP_TO_EDGE,
          min: _l7Core.gl.LINEAR,
          mag: _l7Core.gl.LINEAR
        }),
        depth: false
      });
      this.updateColorTexture();
      return [this.intensityModel, this.colorModel];
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'dir',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Dir',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return [size];
          }
        }
      });
    }
  }, {
    key: "buildHeatMapIntensity",
    value: function buildHeatMapIntensity() {
      return this.layer.buildLayerModel({
        moduleName: 'heatmapintensity',
        vertexShader: heatmapVert,
        fragmentShader: heatmapFrag,
        triangulation: _triangulation.HeatmapTriangulation,
        depth: {
          enable: false
        },
        blend: {
          enable: true,
          func: {
            srcRGB: _l7Core.gl.ONE,
            srcAlpha: 1,
            dstRGB: _l7Core.gl.ONE,
            dstAlpha: 1
          }
        }
      });
    }
  }, {
    key: "buildHeatmapColor",
    value: function buildHeatmapColor() {
      this.shaderModuleService.registerModule('heatmapColor', {
        vs: heatmapColorVert,
        fs: heatmapColorFrag
      });

      var _this$shaderModuleSer = this.shaderModuleService.getModule('heatmapColor'),
          vs = _this$shaderModuleSer.vs,
          fs = _this$shaderModuleSer.fs,
          uniforms = _this$shaderModuleSer.uniforms;

      var _this$rendererService3 = this.rendererService,
          createAttribute = _this$rendererService3.createAttribute,
          createElements = _this$rendererService3.createElements,
          createBuffer = _this$rendererService3.createBuffer,
          createModel = _this$rendererService3.createModel;
      return createModel({
        vs: vs,
        fs: fs,
        attributes: {
          a_Position: createAttribute({
            buffer: createBuffer({
              data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
              type: _l7Core.gl.FLOAT
            }),
            size: 3
          }),
          a_Uv: createAttribute({
            buffer: createBuffer({
              data: [0, 1, 1, 1, 0, 0, 1, 0],
              type: _l7Core.gl.FLOAT
            }),
            size: 2
          })
        },
        uniforms: _objectSpread({}, uniforms),
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        count: 6,
        elements: createElements({
          data: [0, 2, 1, 2, 3, 1],
          type: _l7Core.gl.UNSIGNED_INT,
          count: 6
        })
      });
    }
  }, {
    key: "drawIntensityMode",
    value: function drawIntensityMode() {
      var _ref2 = this.layer.getLayerConfig(),
          opacity = _ref2.opacity,
          _ref2$intensity = _ref2.intensity,
          intensity = _ref2$intensity === void 0 ? 10 : _ref2$intensity,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 5 : _ref2$radius;

      this.intensityModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_radius: radius,
          u_intensity: intensity
        }
      });
    }
  }, {
    key: "drawColorMode",
    value: function drawColorMode() {
      var _ref3 = this.layer.getLayerConfig(),
          opacity = _ref3.opacity;

      this.colorModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_colorTexture: this.colorTexture,
          u_texture: this.heatmapFramerBuffer
        }
      });
    }
  }, {
    key: "draw3DHeatMap",
    value: function draw3DHeatMap() {
      var _ref4 = this.layer.getLayerConfig(),
          opacity = _ref4.opacity;

      var invert = _glMatrix.mat4.invert(_glMatrix.mat4.create(), _glMatrix.mat4.fromValues.apply(_glMatrix.mat4, (0, _toConsumableArray2.default)(this.cameraService.getViewProjectionMatrixUncentered())));

      this.colorModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_colorTexture: this.colorTexture,
          u_texture: this.heatmapFramerBuffer,
          u_ViewProjectionMatrixUncentered: this.cameraService.getViewProjectionMatrixUncentered(),
          u_InverseViewProjectionMatrix: (0, _toConsumableArray2.default)(invert)
        }
      });
    }
  }, {
    key: "build3dHeatMap",
    value: function build3dHeatMap() {
      var getViewportSize = this.rendererService.getViewportSize;

      var _getViewportSize2 = getViewportSize(),
          width = _getViewportSize2.width,
          height = _getViewportSize2.height;

      var triangulation = (0, _triangulation2.heatMap3DTriangulation)(width / 4.0, height / 4.0);
      this.shaderModuleService.registerModule('heatmap3dColor', {
        vs: heatmap3DVert,
        fs: heatmap3DFrag
      });

      var _this$shaderModuleSer2 = this.shaderModuleService.getModule('heatmap3dColor'),
          vs = _this$shaderModuleSer2.vs,
          fs = _this$shaderModuleSer2.fs,
          uniforms = _this$shaderModuleSer2.uniforms;

      var _this$rendererService4 = this.rendererService,
          createAttribute = _this$rendererService4.createAttribute,
          createElements = _this$rendererService4.createElements,
          createBuffer = _this$rendererService4.createBuffer,
          createModel = _this$rendererService4.createModel;
      return createModel({
        vs: vs,
        fs: fs,
        attributes: {
          a_Position: createAttribute({
            buffer: createBuffer({
              data: triangulation.vertices,
              type: _l7Core.gl.FLOAT
            }),
            size: 3
          }),
          a_Uv: createAttribute({
            buffer: createBuffer({
              data: triangulation.uvs,
              type: _l7Core.gl.FLOAT
            }),
            size: 2
          })
        },
        primitive: _l7Core.gl.TRIANGLES,
        uniforms: _objectSpread({}, uniforms),
        depth: {
          enable: true
        },
        blend: {
          enable: true,
          func: {
            srcRGB: _l7Core.gl.SRC_ALPHA,
            srcAlpha: 1,
            dstRGB: _l7Core.gl.ONE_MINUS_SRC_ALPHA,
            dstAlpha: 1
          }
        },
        elements: createElements({
          data: triangulation.indices,
          type: _l7Core.gl.UNSIGNED_INT,
          count: triangulation.indices.length
        })
      });
    }
  }, {
    key: "updateStyle",
    value: function updateStyle() {
      this.updateColorTexture();
    }
  }, {
    key: "updateColorTexture",
    value: function updateColorTexture() {
      var createTexture2D = this.rendererService.createTexture2D;

      if (this.texture) {
        this.texture.destroy();
      }

      var _ref5 = this.layer.getLayerConfig(),
          rampColors = _ref5.rampColors;

      var imageData = (0, _l7Utils.generateColorRamp)(rampColors);
      this.colorTexture = createTexture2D({
        data: new Uint8Array(imageData.data),
        width: imageData.width,
        height: imageData.height,
        wrapS: _l7Core.gl.CLAMP_TO_EDGE,
        wrapT: _l7Core.gl.CLAMP_TO_EDGE,
        min: _l7Core.gl.NEAREST,
        mag: _l7Core.gl.NEAREST,
        flipY: false
      });
    }
  }]);
  return HeatMapModel;
}(_BaseModel2.default);

exports.default = HeatMapModel;
//# sourceMappingURL=heatmap.js.map