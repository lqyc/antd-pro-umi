"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointFillTriangulation = PointFillTriangulation;
exports.PointExtrudeTriangulation = PointExtrudeTriangulation;
exports.PointImageTriangulation = PointImageTriangulation;
exports.LineTriangulation = LineTriangulation;
exports.polygonTriangulation = polygonTriangulation;
exports.PolygonExtrudeTriangulation = PolygonExtrudeTriangulation;
exports.HeatmapGridTriangulation = HeatmapGridTriangulation;
exports.RasterImageTriangulation = RasterImageTriangulation;
exports.LineArcTriangulation = LineArcTriangulation;
exports.HeatmapTriangulation = HeatmapTriangulation;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _l7Utils = require("@antv/l7-utils");

var _earcut = _interopRequireDefault(require("earcut"));

var _glMatrix = require("gl-matrix");

var _extrude_polyline = _interopRequireDefault(require("../utils/extrude_polyline"));

var _geo = require("../utils/geo");

var _extrude = _interopRequireWildcard(require("./shape/extrude"));

var _Path = require("./shape/Path");

var GeometryCache = {};

function PointFillTriangulation(feature) {
  var coordinates = (0, _geo.calculteCentroid)(feature.coordinates);
  return {
    vertices: [].concat((0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates)),
    indices: [0, 1, 2, 2, 3, 0],
    size: coordinates.length
  };
}

function PointExtrudeTriangulation(feature) {
  var shape = feature.shape;

  var _getGeometry = getGeometry(shape, false),
      positions = _getGeometry.positions,
      index = _getGeometry.index,
      normals = _getGeometry.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}

function PointImageTriangulation(feature) {
  var coordinates = (0, _geo.calculteCentroid)(feature.coordinates);
  return {
    vertices: (0, _toConsumableArray2.default)(coordinates),
    indices: [0],
    size: coordinates.length
  };
}

function LineTriangulation(feature) {
  var coordinates = feature.coordinates;
  var path = coordinates;

  if (!Array.isArray(path[0][0])) {
    path = [coordinates];
  }

  var line = new _extrude_polyline.default({
    dash: true,
    join: 'bevel'
  });
  path.forEach(function (item) {
    line.extrude(item);
  });
  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    size: 6
  };
}

function polygonTriangulation(feature) {
  var coordinates = feature.coordinates;

  var flattengeo = _earcut.default.flatten(coordinates);

  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions,
      holes = flattengeo.holes;
  return {
    indices: (0, _earcut.default)(vertices, holes, dimensions),
    vertices: vertices,
    size: dimensions
  };
}

function PolygonExtrudeTriangulation(feature) {
  var coordinates = feature.coordinates;

  var _extrude_PolygonNorma = (0, _extrude.extrude_PolygonNormal)(coordinates, true),
      positions = _extrude_PolygonNorma.positions,
      index = _extrude_PolygonNorma.index,
      normals = _extrude_PolygonNorma.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}

function HeatmapGridTriangulation(feature) {
  var shape = feature.shape;

  var _getHeatmapGeometry = getHeatmapGeometry(shape),
      positions = _getHeatmapGeometry.positions,
      index = _getHeatmapGeometry.index;

  return {
    vertices: positions,
    indices: index,
    size: 3
  };
}

function RasterImageTriangulation(feature) {
  var coordinates = feature.coordinates;
  var positions = [].concat((0, _toConsumableArray2.default)(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], (0, _toConsumableArray2.default)(coordinates[1]), [0, 1, 0], (0, _toConsumableArray2.default)(coordinates[0]), [0, 0, 1], (0, _toConsumableArray2.default)(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);
  var indexs = [0, 1, 2, 3, 4, 5];
  return {
    vertices: positions,
    indices: indexs,
    size: 5
  };
}

function LineArcTriangulation(feature) {
  var segNum = 30;
  var coordinates = feature.coordinates;
  var positions = [];
  var indexArray = [];

  var _loop = function _loop(i) {
    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);

    if (i !== segNum - 1) {
      indexArray.push.apply(indexArray, (0, _toConsumableArray2.default)([0, 1, 2, 1, 3, 2].map(function (v) {
        return i * 2 + v;
      })));
    }
  };

  for (var i = 0; i < segNum; i++) {
    _loop(i);
  }

  return {
    vertices: positions,
    indices: indexArray,
    size: 7
  };
}

function HeatmapTriangulation(feature) {
  var coordinates = feature.coordinates;

  if (coordinates.length === 2) {
    coordinates.push(0);
  }

  var size = feature.size;
  var dir = addDir(-1, 1);
  var dir1 = addDir(1, 1);
  var dir2 = addDir(-1, -1);
  var dir3 = addDir(1, -1);
  var positions = [].concat((0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir2), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir3), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir1));
  var indexArray = [0, 1, 2, 3, 0, 2];
  return {
    vertices: positions,
    indices: indexArray,
    size: 5
  };
}

function getGeometry(shape) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (GeometryCache && GeometryCache[shape]) {
    return GeometryCache[shape];
  }

  var path = _Path.geometryShape[shape] ? _Path.geometryShape[shape]() : _Path.geometryShape.cylinder();
  var geometry = (0, _extrude.extrude_PolygonNormal)([path], needFlat);
  GeometryCache[shape] = geometry;
  return geometry;
}

function computeVertexNormals(positions, indexArray) {
  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var normals = new Float32Array(positions.length / dim * 3);
  var vA;
  var vB;
  var vC;

  var cb = _glMatrix.vec3.create();

  var ab = _glMatrix.vec3.create();

  var normal = _glMatrix.vec3.create();

  for (var i = 0, li = indexArray.length; i < li; i += 3) {
    vA = indexArray[i + 0] * 3;
    vB = indexArray[i + 1] * 3;
    vC = indexArray[i + 2] * 3;
    var p1 = [positions[vA], positions[vA + 1]];
    var p2 = [positions[vB], positions[vB + 1]];
    var p3 = [positions[vC], positions[vC + 1]];

    if (needFlat) {
      p1 = (0, _l7Utils.lngLatToMeters)(p1);
      p2 = (0, _l7Utils.lngLatToMeters)(p2);
      p3 = (0, _l7Utils.lngLatToMeters)(p3);
    }

    var _p = p1,
        _p2 = (0, _slicedToArray2.default)(_p, 2),
        ax = _p2[0],
        ay = _p2[1];

    var pA = _glMatrix.vec3.fromValues(ax, ay, positions[vA + 2]);

    var _p3 = p2,
        _p4 = (0, _slicedToArray2.default)(_p3, 2),
        bx = _p4[0],
        by = _p4[1];

    var pB = _glMatrix.vec3.fromValues(bx, by, positions[vB + 2]);

    var _p5 = p3,
        _p6 = (0, _slicedToArray2.default)(_p5, 2),
        cx = _p6[0],
        cy = _p6[1];

    var pC = _glMatrix.vec3.fromValues(cx, cy, positions[vC + 2]);

    _glMatrix.vec3.sub(cb, pC, pB);

    _glMatrix.vec3.sub(ab, pA, pB);

    _glMatrix.vec3.cross(normal, cb, ab);

    normals[vA] += cb[0];
    normals[vA + 1] += cb[1];
    normals[vA + 2] += cb[2];
    normals[vB] += cb[0];
    normals[vB + 1] += cb[1];
    normals[vB + 2] += cb[2];
    normals[vC] += cb[0];
    normals[vC + 1] += cb[1];
    normals[vC + 2] += cb[2];
  }

  normalizeNormals(normals);
  return normals;
}

function normalizeNormals(normals) {
  for (var i = 0, li = normals.length; i < li; i += 3) {
    var normal = _glMatrix.vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);

    var newNormal = _glMatrix.vec3.create();

    _glMatrix.vec3.normalize(newNormal, normal);

    normals.set(newNormal, i);
  }
}

function checkIsClosed(points) {
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  return p1[0] === p2[0] && p1[1] === p2[1];
}

function getHeatmapGeometry(shape) {
  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];
  var path = _Path.geometryShape[shape] ? _Path.geometryShape[shape]() : _Path.geometryShape.circle();
  var geometry = shape3d.indexOf(shape) === -1 ? (0, _extrude.fillPolygon)([path]) : (0, _extrude.default)([path]);
  return geometry;
}

function addDir(dirX, dirY) {
  var x = (dirX + 1) / 2;
  var y = (dirY + 1) / 2;
  return [x, y];
}
//# sourceMappingURL=triangulation.js.map