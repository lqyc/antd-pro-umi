"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extrudePolygon;
exports.fillPolygon = fillPolygon;
exports.extrude_PolygonNormal = extrude_PolygonNormal;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _l7Utils = require("@antv/l7-utils");

var _earcut = _interopRequireDefault(require("earcut"));

var _glMatrix = require("gl-matrix");

function extrudePolygon(path) {
  var p1 = path[0][0];
  var p2 = path[0][path[0].length - 1];

  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    path[0] = path[0].slice(0, path[0].length - 1);
  }

  var n = path[0].length;

  var flattengeo = _earcut.default.flatten(path);

  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions;
  var positions = [];
  var indexArray = [];

  for (var j = 0; j < vertices.length / dimensions; j++) {
    if (dimensions === 2) {
      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1);
    } else {
      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1);
    }
  }

  var triangles = (0, _earcut.default)(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  indexArray.push.apply(indexArray, (0, _toConsumableArray2.default)(triangles));

  var _loop = function _loop(i) {
    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);
    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);

    if (nextPoint.length === 0) {
      nextPoint = flattengeo.vertices.slice(0, dimensions);
    }

    var indexOffset = positions.length / 3;
    positions.push(prePoint[0], prePoint[1], 1, nextPoint[0], nextPoint[1], 1, prePoint[0], prePoint[1], 0, nextPoint[0], nextPoint[1], 0);
    indexArray.push.apply(indexArray, (0, _toConsumableArray2.default)([0, 2, 1, 2, 3, 1].map(function (v) {
      return v + indexOffset;
    })));
  };

  for (var i = 0; i < n; i++) {
    _loop(i);
  }

  return {
    positions: positions,
    index: indexArray
  };
}

function fillPolygon(points) {
  var flattengeo = _earcut.default.flatten(points);

  var triangles = (0, _earcut.default)(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  return {
    positions: flattengeo.vertices,
    index: triangles
  };
}

function extrude_PolygonNormal(path) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var p1 = path[0][0];
  var p2 = path[0][path[0].length - 1];

  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    path[0] = path[0].slice(0, path[0].length - 1);
  }

  var n = path[0].length;

  var flattengeo = _earcut.default.flatten(path);

  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions;
  var positions = [];
  var indexArray = [];
  var normals = [];

  for (var j = 0; j < vertices.length / dimensions; j++) {
    if (dimensions === 2) {
      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1, -1, -1);
    } else {
      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1, -1, -1);
    }

    normals.push(0, 0, 1);
  }

  var triangles = (0, _earcut.default)(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  indexArray.push.apply(indexArray, (0, _toConsumableArray2.default)(triangles));

  var _loop2 = function _loop2(i) {
    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);
    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);

    if (nextPoint.length === 0) {
      nextPoint = flattengeo.vertices.slice(0, dimensions);
    }

    var indexOffset = positions.length / 5;
    positions.push(prePoint[0], prePoint[1], 1, 0, 0, nextPoint[0], nextPoint[1], 1, 0.1, 0, prePoint[0], prePoint[1], 0, 0, 0.8, nextPoint[0], nextPoint[1], 0, 0.1, 0.8);
    var normal = computeVertexNormals([nextPoint[0], nextPoint[1], 1], [prePoint[0], prePoint[1], 0], [prePoint[0], prePoint[1], 1], needFlat);
    normals.push.apply(normals, (0, _toConsumableArray2.default)(normal).concat((0, _toConsumableArray2.default)(normal), (0, _toConsumableArray2.default)(normal), (0, _toConsumableArray2.default)(normal)));
    indexArray.push.apply(indexArray, (0, _toConsumableArray2.default)([1, 2, 0, 3, 2, 1].map(function (v) {
      return v + indexOffset;
    })));
  };

  for (var i = 0; i < n; i++) {
    _loop2(i);
  }

  return {
    positions: positions,
    index: indexArray,
    normals: normals
  };
}

function computeVertexNormals(p1, p2, p3) {
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var cb = _glMatrix.vec3.create();

  var ab = _glMatrix.vec3.create();

  var normal = _glMatrix.vec3.create();

  if (needFlat) {
    p1 = (0, _l7Utils.lngLatToMeters)(p1);
    p2 = (0, _l7Utils.lngLatToMeters)(p2);
    p3 = (0, _l7Utils.lngLatToMeters)(p3);
  }

  var pA = _glMatrix.vec3.fromValues.apply(_glMatrix.vec3, (0, _toConsumableArray2.default)(p1));

  var pB = _glMatrix.vec3.fromValues.apply(_glMatrix.vec3, (0, _toConsumableArray2.default)(p2));

  var pC = _glMatrix.vec3.fromValues.apply(_glMatrix.vec3, (0, _toConsumableArray2.default)(p3));

  _glMatrix.vec3.sub(cb, pC, pB);

  _glMatrix.vec3.sub(ab, pA, pB);

  _glMatrix.vec3.cross(normal, cb, ab);

  var newNormal = _glMatrix.vec3.create();

  _glMatrix.vec3.normalize(newNormal, normal);

  return newNormal;
}
//# sourceMappingURL=extrude.js.map