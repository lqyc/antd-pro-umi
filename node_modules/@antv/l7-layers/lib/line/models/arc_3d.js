"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _l7Core = require("@antv/l7-core");

var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));

var _triangulation = require("../../core/triangulation");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var line_arc_vert = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\nattribute vec3 a_Position;\nattribute vec4 a_Instance;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform mat4 u_ModelMatrix;\nuniform float segmentNumber;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_distance_ratio;\nuniform float u_line_type: 0.0;\nuniform vec4 u_dash_array: [10.0, 5., 0, 0];\nvarying vec4 v_dash_array;\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  v_color = a_Color;\n  vec2 source = project_position(vec4(a_Instance.rg, 0, 0)).xy;\n  vec2 target = project_position(vec4(a_Instance.ba, 0, 0)).xy;\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n\n   if(u_line_type == LineTypeDash) {\n    v_distance_ratio = segmentIndex / segmentNumber;\n    float total_Distance = pixelDistance(a_Instance.rg, a_Instance.ba) / 2.0 * PI;\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n    if(u_aimate.x == Animate) {\n      v_distance_ratio = segmentIndex / segmentNumber;\n  }\n\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  vec3 curr = getPos(source, target, segmentRatio);\n  vec3 next = getPos(source, target, nextSegmentRatio);\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y);\n  v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n\n  gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z, 1.0));\n  setPickingColor(a_PickingColor);\n}\n";
var line_arc_frag = "#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n\nuniform float u_opacity;\nuniform float u_blur : 0.9;\nuniform float u_line_type: 0.0;\nvarying vec2 v_normal;\nvarying vec4 v_dash_array;\nvarying float v_distance_ratio;\nvarying vec4 v_color;\n\nuniform float u_time;\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\n\n#pragma include \"picking\"\n\nvoid main() {\n  gl_FragColor = v_color;\n  // float blur = 1.- smoothstep(u_blur, 1., length(v_normal.xy));\n  // float blur = smoothstep(1.0, u_blur, length(v_normal.xy));\n  gl_FragColor.a *= u_opacity;\n  if(u_line_type == LineTypeDash) {\n   float flag = 0.;\n    float dashLength = mod(v_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n      flag = 1.;\n    }\n    gl_FragColor.a *=flag;\n  }\n\n  if(u_aimate.x == Animate) {\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\n      alpha = smoothstep(0., 1., alpha);\n      gl_FragColor.a *= alpha;\n  }\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var lineStyleObj = {
  solid: 0.0,
  dash: 1.0
};

var Arc3DModel = function (_BaseModel) {
  (0, _inherits2.default)(Arc3DModel, _BaseModel);

  var _super = _createSuper(Arc3DModel);

  function Arc3DModel() {
    (0, _classCallCheck2.default)(this, Arc3DModel);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(Arc3DModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          opacity = _ref.opacity,
          _ref$lineType = _ref.lineType,
          lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,
          _ref$dashArray = _ref.dashArray,
          dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray;

      if (dashArray.length === 2) {
        dashArray.push(0, 0);
      }

      return {
        u_opacity: opacity || 1,
        segmentNumber: 30,
        u_line_type: lineStyleObj[lineType] || 0.0,
        u_dash_array: dashArray
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      var _ref2 = this.layer.getLayerConfig(),
          animateOption = _ref2.animateOption;

      return {
        u_aimate: this.animateOption2Array(animateOption),
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      return this.buildModels();
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return [this.layer.buildLayerModel({
        moduleName: 'arc3Dline',
        vertexShader: line_arc_vert,
        fragmentShader: line_arc_frag,
        triangulation: _triangulation.LineArcTriangulation,
        blend: this.getBlend()
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'instance',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Instance',
          buffer: {
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4], vertex[5], vertex[6]];
          }
        }
      });
    }
  }]);
  return Arc3DModel;
}(_BaseModel2.default);

exports.default = Arc3DModel;
//# sourceMappingURL=arc_3d.js.map