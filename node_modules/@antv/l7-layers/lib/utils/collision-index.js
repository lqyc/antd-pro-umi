"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _glMatrix = require("gl-matrix");

var _gridIndex = _interopRequireDefault(require("./grid-index"));

var CollisionIndex = function () {
  function CollisionIndex(width, height) {
    (0, _classCallCheck2.default)(this, CollisionIndex);
    this.width = void 0;
    this.height = void 0;
    this.grid = void 0;
    this.viewportPadding = 100;
    this.screenRightBoundary = void 0;
    this.screenBottomBoundary = void 0;
    this.gridRightBoundary = void 0;
    this.gridBottomBoundary = void 0;
    this.width = width;
    this.height = height;
    this.viewportPadding = Math.max(width, height);
    this.grid = new _gridIndex.default(width + this.viewportPadding, height + this.viewportPadding, 25);
    this.screenRightBoundary = width + this.viewportPadding;
    this.screenBottomBoundary = height + this.viewportPadding;
    this.gridRightBoundary = width + 2 * this.viewportPadding;
    this.gridBottomBoundary = height + 2 * this.viewportPadding;
  }

  (0, _createClass2.default)(CollisionIndex, [{
    key: "placeCollisionBox",
    value: function placeCollisionBox(collisionBox) {
      var tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;
      var tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;
      var brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;
      var brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;

      if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {
        return {
          box: []
        };
      }

      return {
        box: [tlX, tlY, brX, brY]
      };
    }
  }, {
    key: "insertCollisionBox",
    value: function insertCollisionBox(box, featureIndex) {
      var key = {
        featureIndex: featureIndex
      };
      this.grid.insert(key, box[0], box[1], box[2], box[3]);
    }
  }, {
    key: "project",
    value: function project(mvpMatrix, x, y) {
      var point = _glMatrix.vec4.fromValues(x, y, 0, 1);

      var out = _glMatrix.vec4.create();

      var mat = _glMatrix.mat4.fromValues.apply(_glMatrix.mat4, (0, _toConsumableArray2.default)(mvpMatrix));

      _glMatrix.vec4.transformMat4(out, point, mat);

      return {
        x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,
        y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding
      };
    }
  }, {
    key: "isInsideGrid",
    value: function isInsideGrid(x1, y1, x2, y2) {
      return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
    }
  }]);
  return CollisionIndex;
}();

exports.default = CollisionIndex;
//# sourceMappingURL=collision-index.js.map