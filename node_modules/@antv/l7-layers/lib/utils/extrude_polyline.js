"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeMiter = computeMiter;
exports.computeNormal = computeNormal;
exports.direction = direction;
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _l7Utils = require("@antv/l7-utils");

var _glMatrix = require("gl-matrix");

var tmp = _glMatrix.vec2.create();

var capEnd = _glMatrix.vec2.create();

var lineA = _glMatrix.vec2.create();

var lineB = _glMatrix.vec2.create();

var tangent = _glMatrix.vec2.create();

function computeMiter(lineTangent, miter, start, end, halfThick) {
  _glMatrix.vec2.add(lineTangent, start, end);

  _glMatrix.vec2.normalize(lineTangent, lineTangent);

  miter = _glMatrix.vec2.fromValues(-lineTangent[1], lineTangent[0]);

  var tmpvec = _glMatrix.vec2.fromValues(-start[1], start[0]);

  return [halfThick / _glMatrix.vec2.dot(miter, tmpvec), miter];
}

function computeNormal(out, dir) {
  return _glMatrix.vec2.set(out, -dir[1], dir[0]);
}

function direction(out, a, b) {
  _glMatrix.vec2.sub(out, a, b);

  _glMatrix.vec2.normalize(out, out);

  return out;
}

function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

function getArrayUnique(matrix) {
  var map = new Map();

  for (var i = 0; i < matrix.length; i++) {
    var key = matrix[0].toString() + '-' + matrix[1].toString();

    if (map.get(key)) {
      matrix.splice(i, 1);
      i++;
    } else {
      map.set(key, key);
    }
  }

  return matrix;
}

var ExtrudePolyline = function () {
  function ExtrudePolyline() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, ExtrudePolyline);
    this.complex = void 0;
    this.join = void 0;
    this.cap = void 0;
    this.miterLimit = void 0;
    this.thickness = void 0;
    this.normal = void 0;
    this.lastFlip = -1;
    this.miter = _glMatrix.vec2.fromValues(0, 0);
    this.started = false;
    this.dash = false;
    this.totalDistance = 0;
    this.join = opts.join || 'miter';
    this.cap = opts.cap || 'butt';
    this.miterLimit = opts.miterLimit || 10;
    this.thickness = opts.thickness || 1;
    this.dash = opts.dash || false;
    this.complex = {
      positions: [],
      indices: [],
      normals: [],
      startIndex: 0
    };
  }

  (0, _createClass2.default)(ExtrudePolyline, [{
    key: "extrude",
    value: function extrude(points) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = i < points.length - 1 ? points[i + 1] : null;
        var amt = this.segment(complex, count, last, cur, next);
        count += amt;
      }

      if (this.dash) {
        for (var _i = 0; _i < complex.positions.length / 6; _i++) {
          complex.positions[_i * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "segment",
    value: function segment(complex, index, last, cur, next) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var capSquare = this.cap === 'square';
      var joinBevel = this.join === 'bevel';
      var flatCur = (0, _l7Utils.aProjectFlat)([cur[0], cur[1]]);
      var flatLast = (0, _l7Utils.aProjectFlat)([last[0], last[1]]);
      direction(lineA, flatCur, flatLast);
      var segmentDistance = 0;

      if (this.dash) {
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }

      if (!this.normal) {
        this.normal = _glMatrix.vec2.create();
        computeNormal(this.normal, lineA);
      }

      if (!this.started) {
        this.started = true;

        if (capSquare) {
          var out1 = _glMatrix.vec2.create();

          var out2 = _glMatrix.vec2.create();

          _glMatrix.vec2.add(out1, this.normal, lineA);

          _glMatrix.vec2.add(out2, this.normal, lineA);

          normals.push(out2[0], out2[1], 0);
          normals.push(out1[0], out1[1], 0);
          positions.push(last[0], last[1], 0, this.totalDistance - segmentDistance, -this.thickness, 0);
          positions.push(last[0], last[1], 0, this.totalDistance - segmentDistance, this.thickness, 0);
        } else {
          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
        }
      }

      indices.push(index + 0, index + 1, index + 2);

      if (!next) {
        computeNormal(this.normal, lineA);

        if (capSquare) {
          var _out = _glMatrix.vec2.create();

          var _out2 = _glMatrix.vec2.create();

          _glMatrix.vec2.sub(_out2, lineA, this.normal);

          _glMatrix.vec2.add(_out, lineA, this.normal);

          normals.push(_out2[0], _out2[1], 0);
          normals.push(_out[0], _out[1], 0);
          positions.push(cur[0], cur[1], 0, this.totalDistance, this.thickness, 0);
          positions.push(cur[0], cur[1], 0, this.totalDistance, this.thickness, 0);
        } else {
          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        }

        indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        var flatNext = (0, _l7Utils.aProjectFlat)([next[0], next[1]]);

        if (isPointEqual(flatCur, flatNext)) {
          _glMatrix.vec2.add(flatNext, flatCur, _glMatrix.vec2.normalize(flatNext, _glMatrix.vec2.subtract(flatNext, flatCur, flatLast)));
        }

        direction(lineB, flatNext, flatCur);

        var _computeMiter = computeMiter(tangent, _glMatrix.vec2.create(), lineA, lineB, this.thickness),
            _computeMiter2 = (0, _slicedToArray2.default)(_computeMiter, 2),
            miterLen = _computeMiter2[0],
            miter = _computeMiter2[1];

        var flip = _glMatrix.vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
        var bevel = joinBevel;

        if (!bevel && this.join === 'miter') {
          var limit = miterLen;

          if (limit > this.miterLimit) {
            bevel = true;
          }
        }

        if (bevel) {
          normals.push(this.normal[0], this.normal[1], 0);
          normals.push(miter[0], miter[1], 0);
          positions.push(cur[0], cur[1], 0, this.totalDistance, -this.thickness * flip, 0);
          positions.push(cur[0], cur[1], 0, this.totalDistance, this.thickness * flip, 0);
          indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          indices.push(index + 2, index + 3, index + 4);
          computeNormal(tmp, lineB);

          _glMatrix.vec2.copy(this.normal, tmp);

          normals.push(this.normal[0], this.normal[1], 0);
          positions.push(cur[0], cur[1], 0, this.totalDistance, -this.thickness * flip, 0);
          count += 3;
        } else {
          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
          indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          flip = -1;

          _glMatrix.vec2.copy(this.normal, miter);

          count += 2;
        }

        this.lastFlip = flip;
      }

      return count;
    }
  }, {
    key: "extrusions",
    value: function extrusions(positions, normals, point, normal, thickness, distanceRadio) {
      normals.push(normal[0], normal[1], 0);
      normals.push(normal[0], normal[1], 0);
      positions.push(point[0], point[1], 0, distanceRadio, -thickness, 0);
      positions.push(point[0], point[1], 0, distanceRadio, thickness, 0);
    }
  }, {
    key: "lineSegmentDistance",
    value: function lineSegmentDistance(b1, a1) {
      var dx = a1[0] - b1[0];
      var dy = a1[1] - b1[1];
      return Math.sqrt(dx * dx + dy * dy);
    }
  }]);
  return ExtrudePolyline;
}();

exports.default = ExtrudePolyline;
//# sourceMappingURL=extrude_polyline.js.map