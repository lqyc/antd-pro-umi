"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeMiter = computeMiter;
exports.computeNormal = computeNormal;
exports.direction = direction;
exports.default = _default;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _l7Utils = require("@antv/l7-utils");

var _glMatrix = require("gl-matrix");

function computeMiter(tangent, miter, lineA, lineB, halfThick) {
  _glMatrix.vec2.add(tangent, lineA, lineB);

  _glMatrix.vec2.normalize(tangent, tangent);

  miter = _glMatrix.vec2.fromValues(-tangent[1], tangent[0]);

  var tmp = _glMatrix.vec2.fromValues(-lineA[1], lineA[0]);

  return halfThick / _glMatrix.vec2.dot(miter, tmp);
}

function computeNormal(out, dir) {
  return _glMatrix.vec2.set(out, -dir[1], dir[0]);
}

function direction(out, a, b) {
  _glMatrix.vec2.sub(out, a, b);

  _glMatrix.vec2.normalize(out, out);

  return out;
}

function extrusions(positions, out, miters, point, normal, scale) {
  addNext(out, miters, normal, -scale);
  addNext(out, miters, normal, scale);
  positions.push(point[0], point[1], 0);
  positions.push(point[0], point[1], 0);
}

function addNext(out, miters, normal, length) {
  out.push(normal[0], normal[1], 0);
  miters.push(length);
}

function lineSegmentDistance(b1, a1) {
  var dx = a1[0] - b1[0];
  var dy = a1[1] - b1[1];
  return Math.sqrt(dx * dx + dy * dy);
}

function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

function _default(points, closed, indexOffset) {
  var isDash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var lineA = _glMatrix.vec2.fromValues(0, 0);

  var lineB = _glMatrix.vec2.fromValues(0, 0);

  var tangent = _glMatrix.vec2.fromValues(0, 0);

  var miter = _glMatrix.vec2.create();

  var started = false;
  var lineNormal = null;

  var tmp = _glMatrix.vec2.create();

  var count = indexOffset || 0;
  var miterLimit = 4;
  var out = [];
  var attrPos = [];
  var attrIndex = [];
  var miters = [];
  var attrDistance = [0, 0];

  if (closed) {
    points = points.slice();
    points.push(points[0]);
  }

  var total = points.length;

  for (var i = 1; i < total; i++) {
    var index = count;

    var last = _glMatrix.vec2.fromValues(points[i - 1][0], points[i - 1][1]);

    var cur = _glMatrix.vec2.fromValues(points[i][0], points[i][1]);

    var next = i < points.length - 1 ? _glMatrix.vec2.fromValues(points[i + 1][0], points[i + 1][1]) : null;

    if (isPointEqual(last, cur)) {
      continue;
    }

    if (next) {
      var nextIndex = i + 1;

      while (next && isPointEqual(cur, next)) {
        next = nextIndex < points.length - 1 ? _glMatrix.vec2.fromValues(points[++nextIndex][0], points[nextIndex][1]) : null;
      }
    }

    var d = 0;
    var flatCur = (0, _l7Utils.aProjectFlat)([cur[0], cur[1]]);
    var flatLast = (0, _l7Utils.aProjectFlat)([last[0], last[1]]);

    if (isDash) {
      var lineDistance = lineSegmentDistance(flatCur, flatLast);
      d = lineDistance + attrDistance[attrDistance.length - 1];
    }

    direction(lineA, flatCur, flatLast);

    if (!lineNormal) {
      lineNormal = _glMatrix.vec2.create();
      computeNormal(lineNormal, lineA);
    }

    if (!started) {
      started = true;
      extrusions(attrPos, out, miters, last, lineNormal, 1);
    }

    attrIndex.push(index + 0, index + 2, index + 1);

    if (!next) {
      computeNormal(lineNormal, lineA);
      extrusions(attrPos, out, miters, cur, lineNormal, 1);
      attrDistance.push(d, d);
      attrIndex.push(index + 1, index + 2, index + 3);
      count += 2;
    } else {
      var flatNext = (0, _l7Utils.aProjectFlat)([next[0], next[1]]);
      direction(lineB, flatNext, flatCur);
      var miterLen = computeMiter(tangent, _glMatrix.vec2.fromValues(miter[0], miter[1]), lineA, lineB, 1);
      var flip = _glMatrix.vec2.dot(tangent, lineNormal) < 0 ? -1 : 1;
      var bevel = Math.abs(miterLen) > miterLimit;

      if (Math.abs(miterLen) > 1000) {
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        attrIndex.push(index + 2, index + 4, index + 3);
        computeNormal(tmp, lineB);

        _glMatrix.vec2.copy(lineNormal, tmp);

        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d);
        count += 4;
        continue;
      }

      if (bevel) {
        miterLen = miterLimit;
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        attrIndex.push.apply(attrIndex, (0, _toConsumableArray2.default)(flip === 1 ? [index + 2, index + 4, index + 5] : [index + 4, index + 5, index + 3]));
        computeNormal(tmp, lineB);

        _glMatrix.vec2.copy(lineNormal, tmp);

        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d);
        count += 4;
      } else {
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        addNext(out, miters, lineNormal, miterLen * -flip);
        attrPos.push(cur[0], cur[1], 0);
        attrIndex.push(index + 2, index + 4, index + 3);
        attrIndex.push(index + 4, index + 5, index + 6);
        computeNormal(tmp, lineB);

        _glMatrix.vec2.copy(lineNormal, tmp);

        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d, d);
        count += 5;
      }
    }
  }

  var pickData = [];

  for (var _i = 0; _i < miters.length; _i++) {
    var totalDistance = attrDistance[attrDistance.length - 1];
    pickData.push(attrPos[_i * 3], attrPos[_i * 3 + 1], attrPos[_i * 3 + 2], attrDistance[_i], miters[_i], totalDistance);
  }

  return {
    normals: out,
    attrIndex: attrIndex,
    attrPos: pickData
  };
}
//# sourceMappingURL=polylineNormal.js.map