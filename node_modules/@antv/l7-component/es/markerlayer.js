import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _merge from "lodash/merge";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { TYPES } from '@antv/l7-core';
import { bindAll, boundsContains, DOM, padBounds, Satistics } from '@antv/l7-utils';
import { EventEmitter } from 'eventemitter3';
import Supercluster from 'supercluster/dist/supercluster';
import Marker from './marker';

var MarkerLayer = function (_EventEmitter) {
  _inherits(MarkerLayer, _EventEmitter);

  var _super = _createSuper(MarkerLayer);

  function MarkerLayer(option) {
    var _this$markerLayerOpti;

    var _this;

    _classCallCheck(this, MarkerLayer);

    _this = _super.call(this);
    _this.markers = [];
    _this.markerLayerOption = void 0;
    _this.clusterIndex = void 0;
    _this.points = [];
    _this.clusterMarkers = [];
    _this.mapsService = void 0;
    _this.scene = void 0;
    _this.zoom = void 0;
    _this.bbox = void 0;
    _this.markerLayerOption = _merge(_this.getDefault(), option);
    bindAll(['update'], _assertThisInitialized(_this));
    _this.zoom = ((_this$markerLayerOpti = _this.markerLayerOption.clusterOption) === null || _this$markerLayerOpti === void 0 ? void 0 : _this$markerLayerOpti.zoom) || -99;
    return _this;
  }

  _createClass(MarkerLayer, [{
    key: "getDefault",
    value: function getDefault() {
      return {
        cluster: false,
        clusterOption: {
          radius: 80,
          maxZoom: 20,
          minZoom: 0,
          zoom: -99,
          style: {},
          className: ''
        }
      };
    }
  }, {
    key: "addTo",
    value: function addTo(scene) {
      this.scene = scene;
      this.mapsService = scene.get(TYPES.IMapService);

      if (this.markerLayerOption.cluster) {
        this.initCluster();
        this.update();
        this.mapsService.on('camerachange', this.update);
      }

      this.addMarkers();
      return this;
    }
  }, {
    key: "addMarker",
    value: function addMarker(marker) {
      var cluster = this.markerLayerOption.cluster;

      if (cluster) {
        this.addPoint(marker, this.markers.length);
      }

      this.markers.push(marker);
    }
  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      this.markers.indexOf(marker);
      var markerIndex = this.markers.indexOf(marker);

      if (markerIndex > -1) {
        this.markers.splice(markerIndex, 1);
      }
    }
  }, {
    key: "getMarkers",
    value: function getMarkers() {
      var cluster = this.markerLayerOption.cluster;
      return cluster ? this.clusterMarkers : this.markers;
    }
  }, {
    key: "addMarkers",
    value: function addMarkers() {
      var _this2 = this;

      this.getMarkers().forEach(function (marker) {
        marker.addTo(_this2.scene);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.markers.forEach(function (marker) {
        marker.remove();
      });
      this.clusterMarkers.forEach(function (clusterMarker) {
        clusterMarker.remove();
      });
      this.mapsService.off('camerachange', this.update);
      this.markers = [];
      this.clusterMarkers = [];
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      this.removeAllListeners();
    }
  }, {
    key: "addPoint",
    value: function addPoint(marker, id) {
      var _marker$getLnglat = marker.getLnglat(),
          lng = _marker$getLnglat.lng,
          lat = _marker$getLnglat.lat;

      var feature = {
        geometry: {
          type: 'Point',
          coordinates: [lng, lat]
        },
        properties: _objectSpread(_objectSpread({}, marker.getExtData()), {}, {
          marker_id: id
        })
      };
      this.points.push(feature);
    }
  }, {
    key: "initCluster",
    value: function initCluster() {
      if (!this.markerLayerOption.cluster) {
        return;
      }

      var _ref = this.markerLayerOption.clusterOption,
          radius = _ref.radius,
          _ref$minZoom = _ref.minZoom,
          minZoom = _ref$minZoom === void 0 ? 0 : _ref$minZoom,
          maxZoom = _ref.maxZoom;
      this.clusterIndex = new Supercluster({
        radius: radius,
        minZoom: minZoom,
        maxZoom: maxZoom
      });
      this.clusterIndex.load(this.points);
    }
  }, {
    key: "getClusterMarker",
    value: function getClusterMarker(viewBounds, zoom) {
      var _this3 = this;

      var viewBBox = viewBounds[0].concat(viewBounds[1]);
      var clusterPoint = this.clusterIndex.getClusters(viewBBox, zoom);
      this.clusterMarkers.forEach(function (marker) {
        marker.remove();
      });
      this.clusterMarkers = [];
      clusterPoint.forEach(function (feature) {
        var _feature$properties;

        var _this3$markerLayerOpt = _this3.markerLayerOption.clusterOption,
            field = _this3$markerLayerOpt.field,
            method = _this3$markerLayerOpt.method;

        if (feature.properties && (_feature$properties = feature.properties) !== null && _feature$properties !== void 0 && _feature$properties.cluster_id) {
          var _feature$properties2;

          var clusterData = _this3.getLeaves((_feature$properties2 = feature.properties) === null || _feature$properties2 === void 0 ? void 0 : _feature$properties2.cluster_id);

          feature.properties.clusterData = clusterData;

          if (field && method) {
            var columnData = clusterData === null || clusterData === void 0 ? void 0 : clusterData.map(function (item) {
              var data = _defineProperty({}, field, item.properties[field]);

              return data;
            });
            var column = Satistics.getColumn(columnData, field);
            var stat = Satistics.getSatByColumn(method, column);
            var fieldName = 'point_' + method;
            feature.properties[fieldName] = stat.toFixed(2);
          }
        }

        var marker = _this3.clusterMarker(feature);

        _this3.clusterMarkers.push(marker);

        marker.addTo(_this3.scene);
      });
    }
  }, {
    key: "getLeaves",
    value: function getLeaves(clusterId) {
      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (!clusterId) {
        return null;
      }

      return this.clusterIndex.getLeaves(clusterId, limit, offset);
    }
  }, {
    key: "clusterMarker",
    value: function clusterMarker(feature) {
      var clusterOption = this.markerLayerOption.clusterOption;
      var _ref2 = clusterOption,
          _ref2$element = _ref2.element,
          element = _ref2$element === void 0 ? this.generateElement.bind(this) : _ref2$element;
      var marker = new Marker({
        element: element(feature)
      }).setLnglat({
        lng: feature.geometry.coordinates[0],
        lat: feature.geometry.coordinates[1]
      });
      return marker;
    }
  }, {
    key: "normalMarker",
    value: function normalMarker(feature) {
      var marker_id = feature.properties.marker_id;
      return this.markers[marker_id];
    }
  }, {
    key: "update",
    value: function update() {
      var zoom = this.mapsService.getZoom();
      var bbox = this.mapsService.getBounds();

      if (!this.bbox || Math.abs(zoom - this.zoom) >= 1 || !boundsContains(this.bbox, bbox)) {
        this.bbox = padBounds(bbox, 0.5);
        this.zoom = Math.floor(zoom);
        this.getClusterMarker(this.bbox, this.zoom);
      }
    }
  }, {
    key: "generateElement",
    value: function generateElement(feature) {
      var el = DOM.create('div', 'l7-marker-cluster');
      var label = DOM.create('div', '', el);
      var span = DOM.create('span', '', label);
      var _this$markerLayerOpti2 = this.markerLayerOption.clusterOption,
          field = _this$markerLayerOpti2.field,
          method = _this$markerLayerOpti2.method;
      feature.properties.point_count = feature.properties.point_count || 1;
      var text = field && method ? feature.properties['point_' + method] || feature.properties[field] : feature.properties.point_count;
      span.textContent = text;
      return el;
    }
  }]);

  return MarkerLayer;
}(EventEmitter);

export { MarkerLayer as default };
//# sourceMappingURL=markerlayer.js.map