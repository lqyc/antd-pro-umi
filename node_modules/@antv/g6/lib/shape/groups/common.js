function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @fileOverview group shapes
 * @author huangtonger@aliyun.com
 */
var Shape = require('../shape');

var Util = require('../../util/');

var Global = require('../../global');

Shape.registerGroup('common', {
  draw: function draw(item) {
    var model = item.getModel();
    var keyShape;

    if (model.collapsed) {
      keyShape = this.drawCollapsed(item);
    } else {
      keyShape = this.drawExpanded(item);
    }

    return keyShape;
  },
  defaultWidth: 184,
  defaultHeight: 40,
  getLabel: function getLabel(item) {
    var model = item.getModel();
    return model.label;
  },
  drawLabel: function drawLabel(item, x, y) {
    var label = this.getLabel(item);

    if (!label) {
      return;
    }

    var group = item.getGraphicGroup();
    var margin = [8, 8];
    x = x + margin[0];
    y = y + margin[1];
    var model = item.getModel();
    var labelOffsetX = model.labelOffsetX,
        labelOffsetY = model.labelOffsetY,
        labelRotate = model.labelRotate;
    x = labelOffsetX ? labelOffsetX + x : x;
    y = labelOffsetY ? labelOffsetY + y : y;
    var attrs = Util.mix(true, {}, Global.labelStyle, {
      x: x,
      y: y,
      textAlign: 'left',
      textBaseline: 'top'
    });

    if (!Util.isObject(label)) {
      attrs.text = label;
    } else {
      Util.mix(attrs, label);
    }

    var labelShape = group.addShape('text', {
      class: 'label',
      attrs: attrs
    });

    if (labelRotate) {
      var textBox = labelShape.getBBox();
      var centerX = (textBox.maxX + textBox.minX) / 2;
      var centerY = (textBox.maxY + textBox.minY) / 2;
      labelShape.transform([['t', -centerX, -centerY], ['r', labelRotate, labelRotate], ['t', centerX, centerY]]);
    }
  },
  drawKeyShape: function drawKeyShape(item, box) {
    var x = box.x,
        y = box.y,
        width = box.width,
        height = box.height;
    var model = item.getModel();
    var group = item.getGraphicGroup();
    var attrs = Util.mix({}, Global.groupStyle, model.style);
    var path = Util.getRectPath(x, y, width, height, attrs.radius);
    item.lastChildrenBox = box;
    return group.addShape('path', {
      attrs: Util.mix({}, attrs, {
        path: path
      })
    });
  },
  getChildrenBBox: function getChildrenBBox(item) {
    var box = _objectSpread({}, item.lastChildrenBox);

    var model = item.getModel();

    if (item.getChildren().length > 0) {
      var childrenBBox = item.getChildrenBBox();
      box.x = childrenBBox.minX - Global.groupBackgroundPadding[3];
      box.y = childrenBBox.minY - Global.groupBackgroundPadding[0];
      box.width = childrenBBox.maxX - childrenBBox.minX + Global.groupBackgroundPadding[3] + Global.groupBackgroundPadding[1];
      box.height = childrenBBox.maxY - childrenBBox.minY + Global.groupBackgroundPadding[0] + Global.groupBackgroundPadding[2];
    } else {
      box.width = this.defaultWidth;
      box.height = this.defaultHeight;
    }

    if (Util.isNil(box.x) && !Util.isNil(model.x)) {
      box.x = model.x;
    }

    if (Util.isNil(box.y) && !Util.isNil(model.y)) {
      box.y = model.y;
    }

    return box;
  },
  drawExpanded: function drawExpanded(item) {
    var box = this.getChildrenBBox(item);
    var keyShape = this.drawKeyShape(item, box);
    this.drawLabel(item, box.x, box.y);
    return keyShape;
  },
  drawCollapsed: function drawCollapsed(item) {
    var box = this.getChildrenBBox(item);
    box.width = this.defaultWidth;
    box.height = this.defaultHeight;
    var keyShape = this.drawKeyShape(item, box);
    this.drawLabel(item, box.x, box.y);
    return keyShape;
  },
  anchor: {
    intersectBox: 'rect'
  }
});