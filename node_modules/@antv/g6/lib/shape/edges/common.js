function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @fileOverview edge shapes
 * @author huangtonger@aliyun.com
 */
var Shape = require('../shape');

var Util = require('../../util/');

var Global = require('../../global');

var MIN_ARROW_SIZE = 3;
var defaultArrow = {
  path: function path(item) {
    var keyShape = item.getKeyShape();
    var lineWidth = keyShape.attr('lineWidth');
    lineWidth = lineWidth > MIN_ARROW_SIZE ? lineWidth : MIN_ARROW_SIZE;
    var width = lineWidth * 10 / 3;
    var halfHeight = lineWidth * 4 / 3;
    var radius = lineWidth * 4;
    return [['M', -width, halfHeight], ['L', 0, 0], ['L', -width, -halfHeight], ['A', radius, radius, 0, 0, 1, -width, halfHeight], ['Z']];
  },
  shorten: function shorten(item) {
    var keyShape = item.getKeyShape();
    var lineWidth = keyShape.attr('lineWidth');
    return (lineWidth > MIN_ARROW_SIZE ? lineWidth : MIN_ARROW_SIZE) * 3.1;
  },
  style: function style(item) {
    var keyShape = item.getKeyShape();

    var _keyShape$attr = keyShape.attr(),
        strokeOpacity = _keyShape$attr.strokeOpacity,
        stroke = _keyShape$attr.stroke;

    return {
      fillOpacity: strokeOpacity,
      fill: stroke
    };
  }
};
Shape.registerEdge('common', {
  draw: function draw(item) {
    var keyShape = this.drawKeyShape(item);
    this.drawLabel(item, keyShape);
    return keyShape;
  },
  drawKeyShape: function drawKeyShape(item) {
    var group = item.getGraphicGroup();
    var style = this.getStyle(item);
    var path = this.getPath(item);
    return group.addShape('path', {
      attrs: Util.mix({}, style, {
        path: path
      })
    });
  },
  getStyle: function getStyle(item) {
    var model = item.getModel();
    return Util.mix(true, {}, {
      stroke: model.color || '#A3B1BF',
      strokeOpacity: 0.92,
      lineAppendWidth: 4,
      lineWidth: model.size || 1
    }, model.style);
  },
  getPath: function getPath(item) {
    var points = item.getPoints();
    return Util.pointsToPolygon(points);
  },
  getLabel: function getLabel(item) {
    var model = item.getModel();
    return model.label;
  },
  getDefaultLabelRectStyle: function getDefaultLabelRectStyle()
  /* item*/
  {
    return {
      fill: 'white'
    };
  },
  getDefaultLabelRectPadding: function getDefaultLabelRectPadding()
  /* item*/
  {
    return Util.toAllPadding([4, 8]);
  },
  drawLabel: function drawLabel(item, keyShape) {
    var label = this.getLabel(item);
    var group = item.getGraphicGroup();
    var model = item.getModel();
    var labelOffsetX = model.labelOffsetX,
        labelOffsetY = model.labelOffsetY,
        labelRotate = model.labelRotate;

    if (label) {
      var center = keyShape.getPoint(0.5);

      if (!center) {
        return;
      }

      center.x = labelOffsetX ? center.x + labelOffsetX : center.x;
      center.y = labelOffsetY ? center.y + labelOffsetY : center.y;
      var attrs = Util.mix(true, {}, Global.labelStyle, center);

      if (!Util.isObject(label)) {
        attrs.text = label;
      } else {
        Util.mix(attrs, label);
      }

      label = group.addShape('text', {
        class: 'label',
        attrs: attrs
      });
      var padding = this.getDefaultLabelRectPadding(item);
      var defaultStyle = this.getDefaultLabelRectStyle(item);
      var textBox = label.getBBox();
      var style = model.labelRectStyle ? Util.mix({}, defaultStyle, model.labelRectStyle) : defaultStyle;
      var rect = group.addShape('rect', {
        attrs: Util.mix({}, style, {
          x: textBox.minX - padding[3],
          y: textBox.minY - padding[0],
          width: textBox.maxX - textBox.minX + padding[1] + padding[3],
          height: textBox.maxY - textBox.minY + padding[0] + padding[2]
        })
      });

      if (labelRotate) {
        var centerX = (textBox.maxX + textBox.minX) / 2;
        var centerY = (textBox.maxY + textBox.minY) / 2; // labelRotate

        label.transform([['t', -centerX, -centerY], ['r', labelRotate, labelRotate], ['t', centerX, centerY]]);
        rect.transform([['t', -centerX, -centerY], ['r', labelRotate, labelRotate], ['t', centerX, centerY]]);
      }

      Util.toFront(label);
    }
  },
  startArrow: _objectSpread({}, defaultArrow, {
    tangent: function tangent(item) {
      var keyShape = item.getKeyShape();
      return keyShape.getStartTangent();
    },
    ratio: function ratio() {
      return 0;
    }
  }),
  endArrow: _objectSpread({}, defaultArrow, {
    tangent: function tangent(item) {
      var keyShape = item.getKeyShape();
      return keyShape.getEndTangent();
    },
    ratio: function ratio() {
      return 1;
    }
  })
});