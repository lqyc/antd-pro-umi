{"version":3,"sources":["../../src/utils/statistics.ts"],"names":["max","x","length","Error","value","i","min","sum","sumNum","correction","transition","Math","abs","mean","statMap"],"mappings":"AAAA,SAASA,GAAT,CAAaC,CAAb,EAA0B;AACxB,MAAIA,CAAC,CAACC,MAAF,KAAa,CAAjB,EAAoB;AAClB,UAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,MAAIC,KAAK,GAAGH,CAAC,CAAC,CAAD,CAAb;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAAC,CAACC,MAAtB,EAA8BG,CAAC,EAA/B,EAAmC;AAGjC,QAAIJ,CAAC,CAACI,CAAD,CAAD,GAAOD,KAAX,EAAkB;AAChBA,MAAAA,KAAK,GAAGH,CAAC,CAACI,CAAD,CAAT;AACD;AACF;;AACD,SAAOD,KAAP;AACD;;AAED,SAASE,GAAT,CAAaL,CAAb,EAA0B;AACxB,MAAIA,CAAC,CAACC,MAAF,KAAa,CAAjB,EAAoB;AAClB,UAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,MAAIC,KAAK,GAAGH,CAAC,CAAC,CAAD,CAAb;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAAC,CAACC,MAAtB,EAA8BG,CAAC,EAA/B,EAAmC;AAGjC,QAAIJ,CAAC,CAACI,CAAD,CAAD,GAAOD,KAAX,EAAkB;AAChBA,MAAAA,KAAK,GAAGH,CAAC,CAACI,CAAD,CAAT;AACD;AACF;;AACD,SAAOD,KAAP;AACD;;AAED,SAASG,GAAT,CAAaN,CAAb,EAA0B;AAExB,MAAIA,CAAC,CAACC,MAAF,KAAa,CAAjB,EAAoB;AAClB,WAAO,CAAP;AACD;;AAGD,MAAIM,MAAM,GAAGP,CAAC,CAAC,CAAD,CAAd;AAGA,MAAIQ,UAAU,GAAG,CAAjB;AAEA,MAAIC,UAAJ;;AAEA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAAC,CAACC,MAAtB,EAA8BG,CAAC,EAA/B,EAAmC;AACjCK,IAAAA,UAAU,GAAGF,MAAM,GAAGP,CAAC,CAACI,CAAD,CAAD,GAAO,CAA7B;;AAIA,QAAIM,IAAI,CAACC,GAAL,CAASJ,MAAT,KAAoBG,IAAI,CAACC,GAAL,CAASX,CAAC,CAACI,CAAD,CAAV,CAAxB,EAAwC;AACtCI,MAAAA,UAAU,IAAID,MAAM,GAAGE,UAAT,GAAsBT,CAAC,CAACI,CAAD,CAArC;AACD,KAFD,MAEO;AACLI,MAAAA,UAAU,IAAIR,CAAC,CAACI,CAAD,CAAD,GAAOK,UAAP,GAAoBF,MAAlC;AACD;;AAEDA,IAAAA,MAAM,GAAGE,UAAT;AACD;;AAGD,SAAOF,MAAM,GAAGC,UAAU,GAAG,CAA7B;AACD;;AACD,SAASI,IAAT,CAAcZ,CAAd,EAA2B;AACzB,MAAIA,CAAC,CAACC,MAAF,KAAa,CAAjB,EAAoB;AAClB,UAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,SAAOI,GAAG,CAACN,CAAD,CAAH,GAASA,CAAC,CAACC,MAAlB;AACD;;AAED,SAASK,GAAT,EAAcP,GAAd,EAAmBM,GAAnB,EAAwBO,IAAxB;AACA,OAAO,IAAMC,OAA+B,GAAG;AAC7CR,EAAAA,GAAG,EAAHA,GAD6C;AAE7CN,EAAAA,GAAG,EAAHA,GAF6C;AAG7Ca,EAAAA,IAAI,EAAJA,IAH6C;AAI7CN,EAAAA,GAAG,EAAHA;AAJ6C,CAAxC","sourcesContent":["function max(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('max requires at least one data point');\n  }\n\n  let value = x[0];\n  for (let i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, max is\n    // undefined and is thus made the maximum element in the array\n    if (x[i] > value) {\n      value = x[i];\n    }\n  }\n  return value;\n}\n\nfunction min(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('min requires at least one data point');\n  }\n\n  let value = x[0];\n  for (let i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, min is\n    // undefined and is thus made the minimum element in the array\n    if (x[i] < value) {\n      value = x[i];\n    }\n  }\n  return value;\n}\n\nfunction sum(x: number[]) {\n  // If the array is empty, we needn't bother computing its sum\n  if (x.length === 0) {\n    return 0;\n  }\n\n  // Initializing the sum as the first number in the array\n  let sumNum = x[0];\n\n  // Keeping track of the floating-point error correction\n  let correction = 0;\n\n  let transition;\n\n  for (let i = 1; i < x.length; i++) {\n    transition = sumNum + x[i] * 1;\n\n    // Here we need to update the correction in a different fashion\n    // if the new absolute value is greater than the absolute sum\n    if (Math.abs(sumNum) >= Math.abs(x[i])) {\n      correction += sumNum - transition + x[i];\n    } else {\n      correction += x[i] - transition + sumNum;\n    }\n\n    sumNum = transition;\n  }\n\n  // Returning the corrected sum\n  return sumNum + correction * 1;\n}\nfunction mean(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  return sum(x) / x.length;\n}\n\nexport { sum, max, min, mean };\nexport const statMap: { [key: string]: any } = {\n  min,\n  max,\n  mean,\n  sum,\n};\n"],"file":"statistics.js"}