import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _mergeWith from "lodash/mergeWith";
import _isString from "lodash/isString";
import _isFunction from "lodash/isFunction";
import _cloneDeep from "lodash/cloneDeep";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { SyncHook } from '@antv/async-hook';
import { bBoxToBounds, extent, padBounds } from '@antv/l7-utils';
import { EventEmitter } from 'eventemitter3';
import { getParser, getTransform } from './';
import { cluster } from './transform/cluster';
import { statMap } from './utils/statistics';
import { getColumn } from './utils/util';

function mergeCustomizer(objValue, srcValue) {
  if (Array.isArray(srcValue)) {
    return srcValue;
  }
}

var Source = function (_EventEmitter) {
  _inherits(Source, _EventEmitter);

  var _super = _createSuper(Source);

  function Source(data, cfg) {
    var _this;

    _classCallCheck(this, Source);

    _this = _super.call(this);
    _this.data = void 0;
    _this.extent = void 0;
    _this.hooks = {
      init: new SyncHook()
    };
    _this.parser = {
      type: 'geojson'
    };
    _this.transforms = [];
    _this.cluster = false;
    _this.clusterOptions = {
      enable: false,
      radius: 40,
      maxZoom: 20,
      zoom: -99,
      method: 'count'
    };
    _this.originData = void 0;
    _this.rawData = void 0;
    _this.cfg = {};
    _this.clusterIndex = void 0;
    _this.originData = data;

    _this.initCfg(cfg);

    _this.hooks.init.tap('parser', function () {
      _this.excuteParser();
    });

    _this.hooks.init.tap('cluster', function () {
      _this.initCluster();
    });

    _this.hooks.init.tap('transform', function () {
      _this.executeTrans();
    });

    _this.init();

    return _this;
  }

  _createClass(Source, [{
    key: "setData",
    value: function setData(data, options) {
      this.rawData = data;
      this.originData = data;
      this.initCfg(options);
      this.init();
      this.emit('update');
    }
  }, {
    key: "getClusters",
    value: function getClusters(zoom) {
      return this.clusterIndex.getClusters(this.extent, zoom);
    }
  }, {
    key: "getClustersLeaves",
    value: function getClustersLeaves(id) {
      return this.clusterIndex.getLeaves(id, Infinity);
    }
  }, {
    key: "updateClusterData",
    value: function updateClusterData(zoom) {
      var _this2 = this;

      var _this$clusterOptions = this.clusterOptions,
          _this$clusterOptions$ = _this$clusterOptions.method,
          method = _this$clusterOptions$ === void 0 ? 'sum' : _this$clusterOptions$,
          field = _this$clusterOptions.field;
      var newBounds = padBounds(bBoxToBounds(this.extent), 2);
      var data = this.clusterIndex.getClusters(newBounds[0].concat(newBounds[1]), Math.floor(zoom));
      this.clusterOptions.zoom = zoom;
      data.forEach(function (p) {
        if (!p.id) {
          p.properties.point_count = 1;
        }
      });

      if (field || _isFunction(method)) {
        data = data.map(function (item) {
          var id = item.id;

          if (id) {
            var points = _this2.clusterIndex.getLeaves(id, Infinity);

            var properties = points.map(function (d) {
              return d.properties;
            });
            var statNum;

            if (_isString(method) && field) {
              var column = getColumn(properties, field);
              statNum = statMap[method](column);
            }

            if (_isFunction(method)) {
              statNum = method(properties);
            }

            item.properties.stat = statNum;
          } else {
            item.properties.point_count = 1;
          }

          return item;
        });
      }

      this.data = getParser('geojson')({
        type: 'FeatureCollection',
        features: data
      });
      this.executeTrans();
    }
  }, {
    key: "getFeatureById",
    value: function getFeatureById(id) {
      var _this$parser$type = this.parser.type,
          type = _this$parser$type === void 0 ? 'geojson' : _this$parser$type;

      if (type === 'geojson' && !this.cluster) {
        var feature = id < this.originData.features.length ? this.originData.features[id] : 'null';

        var newFeature = _cloneDeep(feature);

        if (this.transforms.length !== 0) {
          var item = this.data.dataArray.find(function (dataItem) {
            return dataItem._id === id;
          });
          newFeature.properties = item;
        }

        return newFeature;
      } else {
        return id < this.data.dataArray.length ? this.data.dataArray[id] : 'null';
      }
    }
  }, {
    key: "getFeatureId",
    value: function getFeatureId(field, value) {
      var feature = this.data.dataArray.find(function (dataItem) {
        return dataItem[field] === name;
      });
      return feature === null || feature === void 0 ? void 0 : feature._id;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllListeners();
      this.originData = null;
      this.clusterIndex = null;
      this.data = null;
    }
  }, {
    key: "initCfg",
    value: function initCfg(option) {
      this.cfg = _mergeWith(this.cfg, option, mergeCustomizer);
      var cfg = this.cfg;

      if (cfg) {
        if (cfg.parser) {
          this.parser = cfg.parser;
        }

        if (cfg.transforms) {
          this.transforms = cfg.transforms;
        }

        this.cluster = cfg.cluster || false;

        if (cfg.clusterOptions) {
          this.cluster = true;
          this.clusterOptions = _objectSpread(_objectSpread({}, this.clusterOptions), cfg.clusterOptions);
        }
      }
    }
  }, {
    key: "excuteParser",
    value: function excuteParser() {
      var parser = this.parser;
      var type = parser.type || 'geojson';
      var sourceParser = getParser(type);
      this.data = sourceParser(this.originData, parser);
      this.extent = extent(this.data.dataArray);
    }
  }, {
    key: "executeTrans",
    value: function executeTrans() {
      var _this3 = this;

      var trans = this.transforms;
      trans.forEach(function (tran) {
        var type = tran.type;
        var data = getTransform(type)(_this3.data, tran);
        Object.assign(_this3.data, data);
      });
    }
  }, {
    key: "initCluster",
    value: function initCluster() {
      if (!this.cluster) {
        return;
      }

      var clusterOptions = this.clusterOptions || {};
      this.clusterIndex = cluster(this.data, clusterOptions);
    }
  }, {
    key: "init",
    value: function init() {
      this.hooks.init.call(this);
    }
  }]);

  return Source;
}(EventEmitter);

export { Source as default };
//# sourceMappingURL=source.js.map