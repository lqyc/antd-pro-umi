{"version":3,"file":"attempt.js","sourceRoot":"","sources":["src/attempt.ts"],"names":[],"mappings":";;AAAA,wCAA2C;AAC3C,wCAA2C;AAE3C,qCAAsF;AACtF,6CAAmD;AAEnD,IAAM,SAAS,GAAG,UAAC,EAAc,IAAK,OAAA,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,EAApB,CAAoB,CAAC;AAE3D;;;;;;;;;;;;;;;;;;;;GAoBG;AACU,QAAA,OAAO,GAAG,0BAAgB,CAAC,eAAe,CACrD,IAAI,yBAAe,CAAC,SAAS,EAAE,IAAI,gCAAkB,EAAE,EAAE;IACvD,cAAc,EAAE,IAAI;CACrB,CAAC,CACuB,CAAC;AACR,kBALP,eAAO,CAKO;AAC3B,kBAAe,eAAO,CAAC","sourcesContent":["import attempt = require('lodash/attempt');\nimport partial = require('lodash/partial');\n\nimport { DecoratorConfig, DecoratorFactory, BiTypedMethodDecorator } from './factory';\nimport { PreValueApplicator } from './applicators';\n\nconst attemptFn = (fn: () => void) => partial(attempt, fn);\n\n/**\n * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments are provided to func when it's invoked.\n * @param {...*} [args] The arguments to invoke func with.\n * @example\n *\n * class MyClass {\n *   @Attempt()\n *   fn(value) {\n *     if (typeof value === 'number') {\n *       return value\n *     }\n *\n *     throw new Error();\n *   }\n * }\n *\n * const myClass = new MyClass();\n *\n * myClass.fn(10); // => 10;\n * myClass.fn(null); // => Error\n */\nexport const Attempt = DecoratorFactory.createDecorator(\n  new DecoratorConfig(attemptFn, new PreValueApplicator(), {\n    optionalParams: true\n  })\n) as BiTypedMethodDecorator;\nexport { Attempt as attempt };\nexport default Attempt;\n"]}