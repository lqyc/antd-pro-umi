{"version":3,"file":"bindAll.js","sourceRoot":"","sources":["src/bindAll.ts"],"names":[],"mappings":";;AAAA,8CAAiD;AAEjD,qCAA6C;AAC7C,+BAA8B;AAE9B;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,iBAAwB,OAAsB;IAAtB,wBAAA,EAAA,YAAsB;IAC5C,MAAM,CAAC,UAAC,MAAW;QACjB,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAClC,CAAC,CAAC;AACJ,CAAC;AAJD,0BAIC;AAkCmB,0BAAO;AAhC3B,wBAAwB,MAAgB,EAAE,OAAsB;IAAtB,wBAAA,EAAA,YAAsB;IAC9D,IAAM,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC;IACrC,IAAI,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;IAC7B,IAAM,SAAS,GAAa,EAAE,CAAC;IAE/B,OAAO,KAAK,IAAI,KAAK,KAAK,MAAM,CAAC,SAAS,EAAE,CAAC;QAC3C,GAAG,CAAC,CAAc,UAAiC,EAAjC,KAAA,MAAM,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAjC,cAAiC,EAAjC,IAAiC;YAA9C,IAAM,GAAG,SAAA;YACZ,IAAM,OAAO,GAAG,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC;YACpE,IAAM,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;YAE/D,EAAE,CAAC,CAAC,OAAO,IAAI,GAAG,KAAK,aAAa,CAAC,CAAC,CAAC;gBACrC,kEAAkE;gBAClE,2EAA2E;gBAC3E,EAAE,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;oBACnB,IAAM,SAAS,GAAG,0BAAgB,CAAC,GAAG,CAAC,CAAE,KAAK,EAAE,GAAG,CAAE,CAAC,CAAC;oBAEvD,EAAE,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACtC,QAAQ,CAAC;oBACX,CAAC;gBACH,CAAC;gBAED,EAAE,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5D,MAAM,CAAC,cAAc,CAAC,WAAW,EAAE,GAAG,EAAE,WAAI,CAAC,KAAK,EAAE,GAAG,EAAE,UAAU,CAAE,CAAC,CAAC;oBACvE,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACtB,CAAC;YACH,CAAC;SACF;QAED,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IACvC,CAAC;AACH,CAAC;AAGD,kBAAe,OAAO,CAAC","sourcesContent":["import isFunction = require('lodash/isFunction');\n\nimport { InstanceChainMap } from './factory';\nimport { Bind } from './bind';\n\n/**\n * Binds methods of an object to the object itself, overwriting the existing method.\n * @export\n * @param {string[]} [methods=[]]\n * @returns {ClassDecorator}\n * @example\n *\n * @BindAll()\n * class MyClass {\n *   bound() {\n *     return this;\n *   }\n *\n *   unbound() {\n *     return this;\n *   }\n * }\n *\n * const myClass = new MyClass();\n *\n * myClass.bound.call(null); // => MyClass {}\n * myClass.unbound.call(null); // => MyClass {}\n */\nexport function BindAll(methods: string[] = []): ClassDecorator {\n  return (target: any) => {\n    bindAllMethods(target, methods);\n  };\n}\n\nfunction bindAllMethods(target: Function, methods: string[] = []): void {\n  const targetProto = target.prototype;\n  let proto = target.prototype;\n  const boundKeys: string[] = [];\n\n  while (proto && proto !== Object.prototype) {\n    for (const key of Object.getOwnPropertyNames(proto)) {\n      const include = methods.length ? methods.indexOf(key) !== -1 : true;\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n\n      if (include && key !== 'constructor') {\n        // If this property is a getter and it's NOT an instance decorated\n        // method, ignore it. Instance decorators are getters until first accessed.\n        if (descriptor.get) {\n          const chainData = InstanceChainMap.get([ proto, key ]);\n\n          if (!chainData || !chainData.isMethod) {\n            continue;\n          }\n        }\n\n        if (isFunction(proto[key]) && boundKeys.indexOf(key) === -1) {\n          Object.defineProperty(targetProto, key, Bind(proto, key, descriptor)!);\n          boundKeys.push(key);\n        }\n      }\n    }\n\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n\nexport { BindAll as bindAll };\nexport default BindAll;\n"]}