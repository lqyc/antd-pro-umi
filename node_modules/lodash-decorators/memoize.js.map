{"version":3,"file":"memoize.js","sourceRoot":"","sources":["src/memoize.ts"],"names":[],"mappings":";;AAAA,wCAA2C;AAE3C,qCAKmB;AACnB,6CAAkD;AAGlD;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACU,QAAA,OAAO,GAAG,0BAAgB,CAAC,uBAAuB,CAC7D,IAAI,yBAAe,CAAC,OAAO,EAAE,IAAI,+BAAiB,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,CAAC,CACP,CAAC;AACvD,kBAHP,eAAO,CAGO;AAC3B,kBAAe,eAAO,CAAC","sourcesContent":["import memoize = require('lodash/memoize');\n\nimport {\n  DecoratorConfig,\n  DecoratorFactory,\n  ResolvableFunction,\n  BiTypedMethodDecorator1\n} from './factory';\nimport { MemoizeApplicator } from './applicators';\nimport { MemoizeConfig } from './shared';\n\n/**\n * Creates a function that memoizes the result of func. If resolver is provided,\n * it determines the cache key for storing the result based on the arguments provided to the memoized function.\n * By default, the first argument provided to the memoized function is used as the map cache key.\n * The func is invoked with the this binding of the memoized function.\n *\n * You can use a Function or a string that references a method on the class as the resolver.\n * You can also use a configuration object that lets provide a prexisting cache or specify\n * the map type to use.\n *\n * @example\n *\n * class MyClass {\n *   @Memoize({ type: WeakMap })\n *   getName(item) {\n *     return item.name;\n *   }\n *\n *   @Memoize('getName')\n *   getLastName(item) {\n *     return item.lastName;\n *   }\n * }\n */\nexport const Memoize = DecoratorFactory.createInstanceDecorator(\n  new DecoratorConfig(memoize, new MemoizeApplicator(), { optionalParams: true })\n) as BiTypedMethodDecorator1<ResolvableFunction | MemoizeConfig<any, any>>;\nexport { Memoize as memoize };\nexport default Memoize;\n"]}