/* eslint-disable no-restricted-syntax */
import { useEffect, useMemo, useState } from 'react';
/**
 *
 * @param {object} params
 * @returns {URL}
 */
function setQueryToCurrentUrl(params) {
    var _a;
    const { URL } = window;
    const url = new URL((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href);
    Object.keys(params).forEach((key) => {
        const value = params[key];
        if (value !== null && value !== undefined) {
            if (Array.isArray(value)) {
                url.searchParams.delete(key);
                value.forEach((valueItem) => {
                    url.searchParams.append(key, valueItem);
                });
            }
            else if (value instanceof Date) {
                if (!Number.isNaN(value.getTime())) {
                    url.searchParams.set(key, value.toISOString());
                }
            }
            else if (typeof value === 'object') {
                url.searchParams.set(key, JSON.stringify(value));
            }
            else {
                url.searchParams.set(key, value);
            }
        }
        else {
            url.searchParams.delete(key);
        }
    });
    return url;
}
export function useUrlSearchParams(initial = {}) {
    var _a;
    /**
     * The main idea of this hook is to make things response to change of `window.location.search`,
     * so no need for introducing new state (in the mean time).
     * Whenever `window.location.search` is changed but  not cause re-render, call `forceUpdate()`.
     * Whenever the component - user of this hook - re-render, this hook should return
     * the query object that corresponse to the current `window.location.search`
     */
    const [, forceUpdate] = useState();
    const locationSearch = (_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.search;
    /**
     * @type {URLSearchParams}
     */
    const urlSearchParams = useMemo(() => {
        return new URLSearchParams(locationSearch || {});
    }, [locationSearch]);
    const params = useMemo(() => {
        if (typeof window === undefined || !window.URL)
            return {};
        let result = [];
        // @ts-ignore
        for (const item of urlSearchParams) {
            result.push({
                key: item[0],
                value: item[1],
            });
        }
        // group by key
        result = result.reduce((acc, val) => {
            (acc[val.key] = acc[val.key] || []).push(val);
            return acc;
        }, {});
        result = Object.keys(result).map((key) => {
            const valueGroup = result[key];
            if (valueGroup.length === 1) {
                return [key, valueGroup[0].value];
            }
            return [key, valueGroup.map(({ value }) => value)];
        });
        const newParams = Object.assign({}, initial);
        result.forEach(([key, value]) => {
            newParams[key] = parseValue(key, value, {}, initial);
        });
        return newParams;
    }, [urlSearchParams]);
    function redirectToNewSearchParams(newParams) {
        if (typeof window === undefined || !window.URL)
            return;
        const url = setQueryToCurrentUrl(newParams);
        if (window.location.search !== url.search) {
            window.history.replaceState({}, '', url.toString());
        }
        if (urlSearchParams.toString() !== url.searchParams.toString()) {
            forceUpdate({});
        }
    }
    useEffect(() => {
        if (typeof window === undefined || !window.URL)
            return;
        redirectToNewSearchParams(Object.assign(Object.assign({}, initial), params));
    }, [params]);
    const setParams = (newParams) => {
        redirectToNewSearchParams(newParams);
    };
    useEffect(() => {
        if (typeof window === undefined || !window.URL)
            return () => { };
        const onPopState = () => {
            forceUpdate({});
        };
        window.addEventListener('popstate', onPopState);
        return () => {
            window.removeEventListener('popstate', onPopState);
        };
    }, []);
    return [params, setParams];
}
const booleanValues = {
    true: true,
    false: false,
};
function parseValue(key, _value, types, defaultParams) {
    if (!types)
        return _value;
    const type = types[key];
    const value = _value === undefined ? defaultParams[key] : _value;
    if (type === Number) {
        return Number(value);
    }
    if (type === Boolean || _value === 'true' || _value === 'false') {
        return booleanValues[value];
    }
    if (Array.isArray(type)) {
        // eslint-disable-next-line eqeqeq
        return type.find((item) => item == value) || defaultParams[key];
    }
    return value;
}
