"use strict";

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _uppercamelcase() {
  const data = _interopRequireDefault(require("uppercamelcase"));

  _uppercamelcase = function _uppercamelcase() {
    return data;
  };

  return data;
}

function _rimraf() {
  const data = _interopRequireDefault(require("rimraf"));

  _rimraf = function _rimraf() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

if (!process.env.PAGES_PATH) {
  process.env.PAGES_PATH = 'src';
}

function findGitDir(thePath) {
  if (thePath === '/') {
    return null;
  }

  const items = (0, _fs().readdirSync)(thePath);

  if (items.includes('.git')) {
    return thePath;
  }

  return findGitDir((0, _path().dirname)(thePath));
}

function getNameFromPkg(pkg) {
  if (!pkg.name) {
    return null;
  }

  return pkg.name.split('/').pop();
}

module.exports = function (api) {
  const paths = api.paths,
        logger = api.logger;
  const cwd = paths.cwd || process.cwd();
  const blockPath = (0, _path().join)(cwd, `${process.argv.slice(2)[1] || '.'}`);
  process.env.APP_ROOT = blockPath;
  api.describe({
    config: {
      schema(joi) {
        return joi.object({
          path: joi.string(),
          mockUmiRequest: joi.boolean(),
          menu: joi.object({
            name: joi.string()
          })
        });
      },

      default: {}
    }
  });

  const blockConfig = require((0, _path().join)(paths.cwd || '', 'package.json')).blockConfig;

  const options = api.service.userConfig.blockDevtool || {};
  let subBlocks = []; // 支持区块依赖

  if (blockConfig && blockConfig.dependencies) {
    logger.debug('find dependencies in package.json');
    const gitRoot = findGitDir(api.paths.cwd || '');
    logger.debug(`get gitRoot: ${gitRoot}`);

    if (gitRoot) {
      subBlocks = blockConfig.dependencies.map(d => {
        const subBlockPath = (0, _path().join)(gitRoot, d);

        const subBlockConfig = require((0, _path().join)(subBlockPath, 'package.json'));

        const subBlockName = (0, _uppercamelcase().default)(getNameFromPkg(subBlockConfig) || '');
        return {
          name: subBlockName,
          path: subBlockPath
        };
      });
    } else {
      throw new Error('Not find git root, can not use dependencies.');
    }
  }

  api.onGenerateFiles(() => {
    api.writeTmpFile({
      path: 'block-devtool/layout.tsx',
      content: `
import React from 'react';
import { BasicLayout } from '@ant-design/pro-layout';

export default (props) => {
  const { children } = props;
  return (
    <BasicLayout {...props} pure>
      {children}
    </BasicLayout>
  );
};
    `
    });
  });
  api.modifyConfig(memo => {
    // 这个环境变量是为了截图的时候可以动态设置 layout
    // 所以会优先从 环境变量里面取
    const path = process.env.BLOCK_DEV_PATH || options.path || '/';
    return _objectSpread({}, memo, {
      routes: [{
        path: '/',
        component: '../.umi/block-devtool/layout',
        routes: [_objectSpread({}, options.menu, {
          path,
          component: (0, _path().join)('../', process.argv.slice(2)[1], './src/index'),
          exact: false
        })]
      }]
    });
  }); // link locales 和 models

  ['locales', 'models'].map(dirName => {
    if ((0, _fs().existsSync)((0, _path().join)(cwd, dirName))) {
      _rimraf().default.sync((0, _path().join)(cwd, dirName));
    }

    (0, _fs().mkdirSync)((0, _path().join)(cwd, dirName));
  });
  const localesPath = (0, _path().join)(blockPath, 'src', 'locales');

  if ((0, _fs().existsSync)(localesPath)) {
    // copy 每个文件
    (0, _fs().readdirSync)(localesPath).map(fileName => {
      const copyFilePath = (0, _path().join)(blockPath, 'src', 'locales', fileName);

      if ((0, _fs().existsSync)(copyFilePath)) {
        (0, _fs().copyFileSync)(copyFilePath, (0, _path().join)(cwd, 'locales', fileName));
      }
    });
  } // link models 文件


  ['model.ts', 'service.ts', 'data.d.ts'].map(fileName => {
    const copyFilePath = (0, _path().join)(blockPath, 'src', fileName);

    if ((0, _fs().existsSync)(copyFilePath)) {
      (0, _fs().copyFileSync)(copyFilePath, (0, _path().join)(cwd, 'models', fileName));
    }
  });
  api.addHTMLStyles(() => [{
    content: `
     body,html,#root{
       height:100%
     }
    `
  }]);
  api.chainWebpack(webpackConfig => {
    subBlocks.forEach(b => {
      webpackConfig.resolve.alias.set(`./${b.name}`, (0, _path().join)(b.path, 'src'));
    });
    return webpackConfig;
  });
};