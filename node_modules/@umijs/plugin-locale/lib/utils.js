"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNeedPolyfill = isNeedPolyfill;
exports.exactLocalePaths = exports.getLocaleList = exports.getAntdLocale = exports.getMomentLocale = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _umi() {
  const data = require("umi");

  _umi = function _umi() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const glob = _umi().utils.glob,
      winPath = _umi().utils.winPath,
      lodash = _umi().utils.lodash;

const getMomentLocale = (lang, country) => {
  var _country$toLocaleLowe;

  const momentLocation = require.resolve('moment/locale/zh-cn').replace(/zh\-cn\.js$/, '');

  if ((0, _fs().existsSync)((0, _path().join)(momentLocation, `${lang}-${country === null || country === void 0 ? void 0 : (_country$toLocaleLowe = country.toLocaleLowerCase) === null || _country$toLocaleLowe === void 0 ? void 0 : _country$toLocaleLowe.call(country)}.js`))) {
    var _country$toLocaleLowe2;

    const momentLocale = `${lang}-${country === null || country === void 0 ? void 0 : (_country$toLocaleLowe2 = country.toLocaleLowerCase) === null || _country$toLocaleLowe2 === void 0 ? void 0 : _country$toLocaleLowe2.call(country)}`;
    return {
      momentLocale
    };
  }

  if ((0, _fs().existsSync)((0, _path().join)(momentLocation, `${lang}.js`))) {
    return {
      momentLocale: lang
    };
  }

  return {
    momentLocale: ''
  };
};

exports.getMomentLocale = getMomentLocale;

const getAntdLocale = (lang, country) => `${lang}_${(country || lang).toLocaleUpperCase()}`;

exports.getAntdLocale = getAntdLocale;

const getLocaleList = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (opts) {
    const localeFolder = opts.localeFolder,
          _opts$separator = opts.separator,
          separator = _opts$separator === void 0 ? '-' : _opts$separator,
          _opts$absSrcPath = opts.absSrcPath,
          absSrcPath = _opts$absSrcPath === void 0 ? '' : _opts$absSrcPath,
          _opts$absPagesPath = opts.absPagesPath,
          absPagesPath = _opts$absPagesPath === void 0 ? '' : _opts$absPagesPath,
          addAntdLocales = opts.addAntdLocales;
    const localeFileMath = new RegExp(`^([a-z]{2})${separator}?([A-Z]{2})?\.(js|json|ts)$`);
    const localeFiles = glob.sync('*.{ts,js,json}', {
      cwd: winPath((0, _path().join)(absSrcPath, localeFolder))
    }).map(name => winPath((0, _path().join)(absSrcPath, localeFolder, name))).concat(glob.sync(`**/${localeFolder}/*.{ts,js,json}`, {
      cwd: absPagesPath
    }).map(name => winPath((0, _path().join)(absPagesPath, name)))).filter(p => localeFileMath.test((0, _path().basename)(p)) && (0, _fs().existsSync)(p)).map(fullName => {
      var _localeFileMath$exec, _localeFileMath$exec$;

      const fileName = (0, _path().basename)(fullName);
      const fileInfo = (_localeFileMath$exec = localeFileMath.exec(fileName)) === null || _localeFileMath$exec === void 0 ? void 0 : (_localeFileMath$exec$ = _localeFileMath$exec.slice(1, 3)) === null || _localeFileMath$exec$ === void 0 ? void 0 : _localeFileMath$exec$.filter(Boolean);
      return {
        name: (fileInfo || []).join(separator),
        path: fullName
      };
    });
    const groups = lodash.groupBy(localeFiles, 'name');
    const promises = Object.keys(groups).map( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (name) {
        const _name$split = name.split(separator),
              _name$split2 = _slicedToArray(_name$split, 2),
              lang = _name$split2[0],
              _name$split2$ = _name$split2[1],
              country = _name$split2$ === void 0 ? '' : _name$split2$;

        const _getMomentLocale = getMomentLocale(lang, country),
              momentLocale = _getMomentLocale.momentLocale;

        const antdLocale = lodash.uniq(yield addAntdLocales({
          lang,
          country
        }));
        return {
          lang,
          name,
          // react-intl Function.supportedLocalesOf
          // Uncaught RangeError: Incorrect locale information provided
          locale: name.split(separator).join('-'),
          country,
          antdLocale,
          paths: groups[name].map(item => winPath(item.path)),
          momentLocale
        };
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
    return Promise.all(promises);
  });

  return function getLocaleList(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.getLocaleList = getLocaleList;

const exactLocalePaths = data => {
  return lodash.flatten(data.map(item => item.paths));
};

exports.exactLocalePaths = exactLocalePaths;

function isNeedPolyfill(targets = {}) {
  // data come from https://caniuse.com/#search=intl
  // you can find all browsers in https://github.com/browserslist/browserslist#browsers
  const polyfillTargets = {
    ie: 10,
    firefox: 28,
    chrome: 23,
    safari: 9.1,
    opera: 12.1,
    ios: 9.3,
    ios_saf: 9.3,
    operamini: Infinity,
    op_mini: Infinity,
    android: 4.3,
    blackberry: Infinity,
    operamobile: 12.1,
    op_mob: 12.1,
    explorermobil: 10,
    ie_mob: 10,
    ucandroid: Infinity
  };
  return Object.keys(targets).find(key => {
    const lowKey = key.toLocaleLowerCase();
    return polyfillTargets[lowKey] && polyfillTargets[lowKey] >= targets[key];
  }) !== undefined;
}